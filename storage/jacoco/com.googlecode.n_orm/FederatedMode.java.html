<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FederatedMode.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">n-orm core</a> &gt; <a href="index.html" class="el_package">com.googlecode.n_orm</a> &gt; <span class="el_source">FederatedMode.java</span></div><h1>FederatedMode.java</h1><pre class="source lang-java linenums"><span class="pc" id="L1">package com.googlecode.n_orm;</span>

import com.googlecode.n_orm.storeapi.Store;

/**
 * The different consistency possibilities for a table to be federated.
 * &lt;p&gt;
 * Consistency, for federated tables, consists in avoiding having duplicated
 * rows within two different tables. This can happen depending whether result
 * for the postfix computation (as given by
 * {@link PersistingElementOverFederatedTable#getTablePostfix()}) keep constant
 * with time, that is it always returns the same value for a given persisting
 * element.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Three solutions are proposed to check for consistency:
 * &lt;ul&gt;
 * &lt;li&gt;Throwing an {@link IllegalStateException} when postfix computation
 * changes over time (computation consistency)
 * &lt;li&gt;Check existence of identifier for an element in all table alternatives
 * before reading it from data store ; this way, actual table postfix is
 * searched in the data store in preference of calling
 * {@link PersistingElementOverFederatedTable#getTablePostfix()} on read
 * operations
 * &lt;li&gt;Check existence of identifier for an element in all table alternatives
 * before writing it to data store ; this way, actual table postfix is searched
 * in the data store in preference of calling
 * {@link PersistingElementOverFederatedTable#getTablePostfix()} on write
 * operations
 * &lt;/ul&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Full consistency, be it for read or write, consists in checking existence of
 * the element's identifier in alternative tables. All alternative tables are
 * queried for the existence of the identifier (using
 * {@link Store#exists(com.googlecode.n_orm.storeapi.MetaInformation, String, String)}).
 * Tables are queried in sequence in probability order:
 * &lt;ol&gt;
 * &lt;li&gt;table with computed postfix
 * &lt;li&gt;table with no postfix (a.k.a. original table, i.e. the table in which the
 * element would be located in case it is not using federated tables)
 * &lt;li&gt;alternative tables already known
 * &lt;li&gt;all alternative tables found from the data store as they are saved in a
 * special meta table
 * &lt;/ol&gt;
 * &lt;/p&gt;
 * &lt;p&gt;
 * Achieving full consistency obviously requires a multiple queries on the data
 * store just for sake of checks. To reduce number of checks, it is possible to
 * restrict consistency checks to the original table, i.e. ignore tables of
 * points 3 and 4. This mode is called &quot;consistency with legacy&quot; as it keeps the
 * table federation consistent when a persisting class is changed from not
 * federated to federated.
 * &lt;/p&gt;
 * &lt;p&gt;
 * Enumerated values are named using the following general pattern:
 * &lt;ol&gt;
 * &lt;li&gt;PC when computed postfix should not change over time
 * &lt;li&gt;RCONS (read consistency) or RLEG (read legacy consistency) when read
 * operations trigger consistency checks to determine actual postfix before any
 * read operation (like {@link PersistingElement#activate(String...)} or
 * {@link PersistingElement#existsInStore()})
 * &lt;li&gt;WCONS (write consistency) or WLEG (write legacy consistency) when read
 * operations trigger consistency checks to determine actual postfix before any
 * read operation (like {@link PersistingElement#store()})
 * &lt;/ol&gt;
 * When read and write operation should the the same level of consistency
 * checks, only consistency level is indicated. Note that
 * {@link PersistingElement#delete()} uses the most consistent mode between read
 * and write consistency.
 * &lt;/p&gt;
 * 
 * @see FederatedTableManagement FederatedTableManagement for more
 *      implementation details
 */
<span class="fc" id="L76">public enum FederatedMode {</span>
<span class="fc" id="L77">	/**</span>
	 * A single table (the original table) is to be used for storing elements.
	 */
<span class="fc" id="L80">	NONE(),</span>
<span class="fc" id="L81">	/**</span>
	 * Table for elements is postfixed by result of
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. This can
	 * be dangerous if the latter result changes over time for a given element
	 * as an element can appear in different tables and only one table will be
	 * used for operations.
	 */
<span class="fc" id="L88">	INCONS(false, Consistency.NONE, Consistency.NONE),</span>
<span class="fc" id="L89">	/**</span>
	 * Table for elements is postfixed by result of
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Result for
	 * the latter operation are regularly checked not to change over time.
	 */
<span class="fc" id="L94">	PC_INCONS(true, Consistency.NONE, Consistency.NONE),</span>
<span class="fc" id="L95">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any read operation.
	 */
<span class="fc" id="L101">	RLEG(false, Consistency.CONSISTENT_WITH_LEGACY, Consistency.NONE),</span>
<span class="fc" id="L102">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any read operation. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L110">	PC_RLEG(true, Consistency.CONSISTENT_WITH_LEGACY, Consistency.NONE),</span>
<span class="fc" id="L111">	/**</span>
	 * Find from the datastore actual table for elements prior to any read
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}.
	 */
<span class="fc" id="L116">	RCONS(false, Consistency.CONSISTENT, Consistency.NONE),</span>
<span class="fc" id="L117">	/**</span>
	 * Find from the datastore actual table for elements prior to any read
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L124">	PC_RCONS(true, Consistency.CONSISTENT, Consistency.NONE),</span>
<span class="fc" id="L125">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any write operation.
	 */
<span class="fc" id="L131">	WLEG(false, Consistency.NONE, Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L132">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any write operation. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L140">	PC_WLEG(true, Consistency.NONE, Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L141">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any read or write operation.
	 */
<span class="fc" id="L147">	LEG(false, Consistency.CONSISTENT_WITH_LEGACY,</span>
<span class="fc" id="L148">			Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L149">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any write operation. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L157">	PC_LEG(true, Consistency.CONSISTENT_WITH_LEGACY,</span>
<span class="fc" id="L158">			Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L159">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any read operation. Regarding write operation, only table with no postfix
	 * is checked.
	 */
<span class="fc" id="L166">	RCONS_WLEG(false, Consistency.CONSISTENT,</span>
<span class="fc" id="L167">			Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L168">	/**</span>
	 * Finds from the datastore whether table for this element is the original
	 * table or table postfixed with
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} prior to
	 * any read operation. Regarding write operation, only table with no postfix
	 * is checked. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L177">	PC_RCONS_WLEG(true, Consistency.CONSISTENT,</span>
<span class="fc" id="L178">			Consistency.CONSISTENT_WITH_LEGACY),</span>
<span class="fc" id="L179">	/**</span>
	 * Find from the datastore actual table for elements prior to any write
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}.
	 */
<span class="fc" id="L184">	WCONS(false, Consistency.NONE, Consistency.CONSISTENT),</span>
<span class="fc" id="L185">	/**</span>
	 * Find from the datastore actual table for elements prior to any write
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L192">	PC_WCONS(true, Consistency.NONE, Consistency.CONSISTENT),</span>
<span class="fc" id="L193">	/**</span>
	 * Find from the datastore actual table for elements prior to any write
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Regarding
	 * read operation, only table with no postfix is checked.
	 */
<span class="fc" id="L199">	RLEG_WCONS(false, Consistency.CONSISTENT_WITH_LEGACY,</span>
<span class="fc" id="L200">			Consistency.CONSISTENT),</span>
<span class="fc" id="L201">	/**</span>
	 * Find from the datastore actual table for elements prior to any write
	 * operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Regarding
	 * read operation, only table with no postfix is checked. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L209">	PC_RLEG_WCONS(true, Consistency.CONSISTENT_WITH_LEGACY,</span>
<span class="fc" id="L210">			Consistency.CONSISTENT),</span>
<span class="fc" id="L211">	/**</span>
	 * Find from the datastore actual table for elements prior to any read or
	 * write operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}.
	 */
<span class="fc" id="L216">	CONS(false, Consistency.CONSISTENT, Consistency.CONSISTENT),</span>
<span class="fc" id="L217">	/**</span>
	 * Find from the datastore actual table for elements prior to any read or
	 * write operation before calling
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()}. Result for
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * regularly checked to be consistent in case table is postfixed.
	 */
<span class="fc" id="L224">	PC_CONS(true, Consistency.CONSISTENT, Consistency.CONSISTENT), ;</span>

	private final boolean federated;
	private final boolean checkForChangingPostfix;
	private final Consistency readConsistency;
	private final Consistency writeConsistency;

	// Not federated
<span class="fc" id="L232">	FederatedMode() {</span>
<span class="fc" id="L233">		this.federated = false;</span>
<span class="fc" id="L234">		this.checkForChangingPostfix = false;</span>
<span class="fc" id="L235">		this.readConsistency = Consistency.NONE;</span>
<span class="fc" id="L236">		this.writeConsistency = Consistency.NONE;</span>
<span class="fc" id="L237">	}</span>

	// Federated
<span class="fc" id="L240">	FederatedMode(boolean checkForChangingPostfix,</span>
			Consistency readConsistency,
			Consistency writeConsistency) {
<span class="fc" id="L243">		this.federated = true;</span>
<span class="fc" id="L244">		this.checkForChangingPostfix = checkForChangingPostfix;</span>
<span class="fc" id="L245">		this.readConsistency = readConsistency;</span>
<span class="fc" id="L246">		this.writeConsistency = writeConsistency;</span>
<span class="fc" id="L247">	}</span>

	/**
	 * Whether elements of this persisting class might be stored in another able
	 * than that one stated by {@link PersistingMixin#getTable(Class)}
	 */
	public boolean isFederated() {
<span class="fc" id="L254">		return federated;</span>
	}

	/**
	 * Whether elements of this persisting class should be checked for coherent
	 * results for {@link PersistingElementOverFederatedTable#getTablePostfix()}
	 */
	public boolean isCheckForChangingPostfix() {
<span class="fc" id="L262">		return checkForChangingPostfix;</span>
	}

	public Consistency getConsistency(ReadWrite mode) {
<span class="pc bpc" id="L266" title="1 of 4 branches missed.">		switch (mode) {</span>
		case READ:
<span class="fc" id="L268">			return this.readConsistency;</span>
		case WRITE:
<span class="fc" id="L270">			return this.writeConsistency;</span>
		case READ_OR_WRITE:
<span class="fc bfc" id="L272" title="All 2 branches covered.">			if (this.readConsistency.compareTo(this.writeConsistency) &gt; 0)</span>
<span class="fc" id="L273">				return this.readConsistency;</span>
			else
<span class="fc" id="L275">				return this.writeConsistency;</span>
		}
<span class="nc" id="L277">		throw new Error(&quot;Unknown consistency mode &quot; + mode);</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>