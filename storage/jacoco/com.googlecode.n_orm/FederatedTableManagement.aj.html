<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>FederatedTableManagement.aj</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">n-orm core</a> &gt; <a href="index.html" class="el_package">com.googlecode.n_orm</a> &gt; <span class="el_source">FederatedTableManagement.aj</span></div><h1>FederatedTableManagement.aj</h1><pre class="source lang-java linenums"><span class="pc bpc" id="L1" title="9 of 32 branches missed.">package com.googlecode.n_orm;</span>

import java.lang.reflect.Field;
import java.util.Collection;
import java.util.Collections;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import com.googlecode.n_orm.query.SearchableClassConstraintBuilder;
import com.googlecode.n_orm.storeapi.CloseableKeyIterator;
import com.googlecode.n_orm.storeapi.Constraint;
import com.googlecode.n_orm.storeapi.DefaultColumnFamilyData;
import com.googlecode.n_orm.storeapi.MetaInformation;
import com.googlecode.n_orm.storeapi.Row;
import com.googlecode.n_orm.storeapi.Row.ColumnFamilyData;
import com.googlecode.n_orm.storeapi.Store;
import com.googlecode.n_orm.storeapi.ActionnableStore;
import com.googlecode.n_orm.storeapi.DelegatingStore;
import com.googlecode.n_orm.utils.AggregatingIterator;

/**
 * Makes it possible to look for elements of a given class from/to different
 * alternative tables. In the following documentation, &quot;original table&quot; refers
 * to the table in which elements of a given class are stored when not federated
 * (see {@link PersistingMixin#getTable(Class)}). Alternatives are both cached
 * and registered in the data store using table {@link #FEDERATED_META_TABLE}
 * and family {@link #FEDERATED_META_COLUMN_FAMILY} ; key is the name of the
 * original table, and qualifiers are the possible alternatives.
 * 
 * @see Persisting#federated()
 * @see Persisting.FederatedMode
 */
<span class="pc" id="L50">public aspect FederatedTableManagement {</span>
	
	declare precedence: PersistingMixin, FederatedTableManagement;
	
	/**
	 * Table where alternative tables (for a given table) will be stored. The
	 * key is the name of the original table, and columns (in the
	 * {@link #FEDERATED_META_COLUMN_FAMILY} family) the alternatives.
	 */
	public static final String FEDERATED_META_TABLE = &quot;n-orm-federated-tables&quot;;
	/**
	 * The column family in which alternative tables are stored.
	 * 
	 * @see #FEDERATED_META_TABLE
	 */
	public static final String FEDERATED_META_COLUMN_FAMILY = &quot;t&quot;;

	/**
	 * The time (in ms) during which table alternatives are not loaded again
	 * from the base ; default is 1s
	 */
<span class="fc" id="L71">	public static long TableAlternativeCacheTTLInS = 10000;</span>

	/**
	 * The time (in ms) during which table alternatives are not loaded again
	 * from the base ; default is 1s
	 */
	public static long getTableAlternativeCacheTTLInS() {
<span class="fc" id="L78">		return TableAlternativeCacheTTLInS;</span>
	}

	/**
	 * The time (in s) during which table alternatives are not loaded again from
	 * the base ; default is 1s
	 */
	public static void setTableAlternativeCacheTTLInS(
			long tableAlternativeCacheTTLInS) {
<span class="fc" id="L87">		TableAlternativeCacheTTLInS = tableAlternativeCacheTTLInS;</span>
<span class="fc" id="L88">	}</span>

<span class="fc" id="L90">	private static int ParallelGlobalSearch = 5;</span>

	/**
	 * The maximum number of threads to be used while performing global actions
	 * like a {@link SearchableClassConstraintBuilder#count() counting} or
	 * {@link SearchableClassConstraintBuilder#go() grabbing} elements from a
	 * class.
	 * Default is 5.
	 */
	public static int getParallelGlobalSearch() {
<span class="fc" id="L100">		return ParallelGlobalSearch;</span>
	}

	/**
	 * The maximum number of threads to be used while performing global actions
	 * like a {@link SearchableClassConstraintBuilder#count() counting} or
	 * {@link SearchableClassConstraintBuilder#go() grabbing} elements from a
	 * class.
	 * Default is 5.
	 */
	public static void setParallelGlobalSearch(int parallelGlobalSearch) {
<span class="nc bnc" id="L111" title="All 2 branches missed.">		if (parallelGlobalSearch &lt;= 0)</span>
<span class="nc" id="L112">			throw new IllegalArgumentException(&quot;Cannot have less than one global search tasks while attempting to set &quot; + parallelGlobalSearch);</span>
<span class="nc" id="L113">		ParallelGlobalSearch = parallelGlobalSearch;</span>
<span class="nc" id="L114">	}</span>

	// REM: a federated element can only inherit federated elements with similar
	// configuration
	declare parents: (@Persisting(federated!=FederatedMode.NONE) *) implements PersistingElementOverFederatedTable;

	/**
	 * A place where to register alternatives for an original table. Alternative
	 * tables can be registered or updated from the store using table
	 * {@link FederatedTableManagement#FEDERATED_META_TABLE} and family
	 * {@link FederatedTableManagement#FEDERATED_META_COLUMN_FAMILY}. Updates
	 * occurs at most each
	 * {@link FederatedTableManagement#TableAlternativeCacheTTLInS} seconds.
	 */
	private final static class TableAlternatives {
		/**
		 * The original table
		 */
		private final String mainTable;

		/**
		 * When alternatives for {@link #mainTable} was last updated (epoch in
		 * seconds)
		 */
<span class="fc" id="L138">		private volatile long lastUpdate = -TableAlternativeCacheTTLInS;</span>

		/**
		 * Known table postfixes for {@link #mainTable}
		 */
<span class="fc" id="L143">		private Set&lt;String&gt; postfixes = new TreeSet&lt;String&gt;();</span>
		
<span class="fc" id="L145">		private Boolean hasLegacy = null;</span>
<span class="fc" id="L146">		private volatile long legacyUpdate = 0;</span>
		
<span class="fc" id="L148">		public TableAlternatives(String mainTable) {</span>
<span class="fc" id="L149">			this.mainTable = mainTable;</span>
<span class="fc" id="L150">		}</span>
		
		/**
		 * Returns the store bypassing any cache.
		 */
		private Store getActualStore(Store store) {
<span class="pc bpc" id="L156" title="1 of 2 branches missed.">			return store instanceof DelegatingStore ? ((DelegatingStore)store).getActualStore() : store;</span>
		}
		
		/**
		 * Whether we believe legacy table (main table) exists
		 */
		public boolean legacyExists(Store store) {
<span class="fc" id="L163">			long now = System.currentTimeMillis();</span>
<span class="pc bpc" id="L164" title="1 of 4 branches missed.">			if (hasLegacy == null || (legacyUpdate + TableAlternativeCacheTTLInS) &lt; now) {</span>
<span class="fc" id="L165">				this.hasLegacy = store.hasTable(this.mainTable);</span>
<span class="fc" id="L166">				this.legacyUpdate = now;</span>
			}
<span class="fc" id="L168">			return this.hasLegacy;</span>
		}

		/**
		 * Updates alternatives according to meta-informations stored in the
		 * store. An update (for this object) can happen at most each
		 * {@link FederatedTableManagement#TableAlternativeCacheTTLInS} ms.
		 * 
		 * @param store
		 *            where alternative meta-information should be retrieved
		 *            from ; should be the store for a class having
		 *            {@link #mainTable} as original table
		 * @return postfixes that appeared with the update ; empty in case
		 *         tables were not updated from store
		 */
		protected void updateAlternatives(Store store) {
<span class="fc" id="L184">			long now = System.currentTimeMillis();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">			if ((this.lastUpdate + TableAlternativeCacheTTLInS) &lt; now) {</span>
<span class="pc" id="L186">				synchronized(this) {</span>
<span class="fc" id="L187">					now = System.currentTimeMillis();</span>
<span class="pc bpc" id="L188" title="1 of 2 branches missed.">					if ((this.lastUpdate + TableAlternativeCacheTTLInS) &lt; now) {</span>
						// OK, we should update
		
						// Reminding when alternatives were last updated
<span class="fc" id="L192">						this.lastUpdate = now;</span>
						
						//Bypassing any cache
<span class="fc" id="L195">						store = this.getActualStore(store);</span>
		
						// Querying the store (to be found as qualifiers for columns)
						// Table is FEDERATED_META_TABLE
						// key is the original table
						// family is FEDERATED_META_COLUMN_FAMILY
						// obtained cell qualifiers are the stored alternatives.
<span class="fc" id="L202">						Map&lt;String, byte[]&gt; res = store.get(null, FEDERATED_META_TABLE,</span>
<span class="fc" id="L203">								this.mainTable, FEDERATED_META_COLUMN_FAMILY);</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">						Set&lt;String&gt; newPosts = res == null ? new TreeSet&lt;String&gt;()</span>
<span class="fc" id="L205">								: new TreeSet&lt;String&gt;(res.keySet());</span>
		
						// We should always care about legacy table
<span class="fc bfc" id="L208" title="All 2 branches covered.">						boolean ckeckForLegacyTable = !newPosts.contains(&quot;&quot;);</span>
		
						// Checking for deleted tables in order to remove them from
						// stored alternatives
<span class="fc" id="L212">						Iterator&lt;String&gt; newAlternativesIt = newPosts.iterator();</span>
<span class="fc" id="L213">						Set&lt;String&gt; deletedPosts = new TreeSet&lt;String&gt;();</span>
<span class="fc bfc" id="L214" title="All 2 branches covered.">						while (newAlternativesIt.hasNext()) {</span>
<span class="fc" id="L215">							String post = newAlternativesIt.next();</span>
<span class="pc bpc" id="L216" title="1 of 2 branches missed.">							if (!store.hasTable(this.mainTable + post)) {</span>
<span class="nc" id="L217">								newAlternativesIt.remove();</span>
<span class="nc" id="L218">								deletedPosts.add(post);</span>
							}
						}
						// Removing deleted tables from stored alternatives
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">						if (!deletedPosts.isEmpty()) {</span>
<span class="nc" id="L223">							Map&lt;String, Set&lt;String&gt;&gt; removed = new TreeMap&lt;String, Set&lt;String&gt;&gt;();</span>
<span class="nc" id="L224">							removed.put(FEDERATED_META_COLUMN_FAMILY, deletedPosts);</span>
<span class="nc" id="L225">							store.storeChanges(null, FEDERATED_META_TABLE,</span>
<span class="nc" id="L226">									this.mainTable, null, removed, null);</span>
						}
		
						// Checking for legacy table
<span class="fc bfc" id="L230" title="All 2 branches covered.">						if (ckeckForLegacyTable) {</span>
<span class="fc bfc" id="L231" title="All 2 branches covered.">							if (store.hasTable(mainTable)) {</span>
<span class="fc" id="L232">								this.addPostfix(&quot;&quot;, store);</span>
<span class="fc" id="L233">								newPosts.add(&quot;&quot;);</span>
<span class="fc" id="L234">								this.hasLegacy = Boolean.TRUE;</span>
							} else {
<span class="fc" id="L236">								this.hasLegacy = Boolean.FALSE;</span>
							}
						} else {
<span class="fc" id="L239">							this.hasLegacy = Boolean.TRUE;</span>
						}
<span class="fc" id="L241">						this.legacyUpdate = now;</span>
		
						// Recording last state
<span class="fc" id="L244">						this.postfixes = newPosts;</span>
					}
				}
			}
<span class="fc" id="L248">		}</span>

		/**
		 * Registering a new alternative postfix for {@link #mainTable}. In case
		 * this postfix was not known, it is stored in the given data store
		 * 
		 * @param postfix
		 *            the new alternative postfix
		 * @param store
		 *            the store to which register this new alternative ; should
		 *            be the store for a class having {@link #mainTable} as
		 *            original table. null in case no write have ever been done
		 */
		public void addPostfix(String postfix, Store store) {
<span class="fc bfc" id="L262" title="All 2 branches covered.">			if (!this.postfixes.contains(postfix)) {</span>
<span class="pc" id="L263">				synchronized(this) {</span>
<span class="pc bpc" id="L264" title="1 of 2 branches missed.">					if (this.postfixes.add(postfix)) {</span>
						
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">						if (store != null) {</span>
							
							// We were not aware of that alternative ;
							// let's register in the store
							
							//Bypassing any cache
<span class="fc" id="L272">							store = this.getActualStore(store);</span>
							
							// Table is FEDERATED_META_TABLE
							// key is the original table
							// family is FEDERATED_META_COLUMN_FAMILY
							// new alternative is the qualifier for an empty cell
<span class="fc" id="L278">							ColumnFamilyData changes = new DefaultColumnFamilyData();</span>
<span class="fc" id="L279">							Map&lt;String, byte[]&gt; change = new TreeMap&lt;String, byte[]&gt;();</span>
<span class="fc" id="L280">							changes.put(FEDERATED_META_COLUMN_FAMILY, change);</span>
<span class="fc" id="L281">							change.put(postfix, null);</span>
<span class="fc" id="L282">							store.storeChanges(null, FEDERATED_META_TABLE, this.mainTable,</span>
<span class="fc" id="L283">									changes, null, null);</span>
						}
					}
				}
			}
<span class="fc" id="L288">		}</span>

		/**
		 * The known alternative postfixes for {@link #mainTable}
		 */
		public Set&lt;String&gt; getPostfixes() {
<span class="fc" id="L294">			return Collections.unmodifiableSet(this.postfixes);</span>
		}
	}

	// Cache for storing table variants (no TTL)
<span class="fc" id="L299">	private static final ConcurrentMap&lt;String /* main table */, TableAlternatives&gt; tablesAlternatives = new ConcurrentHashMap&lt;String, TableAlternatives&gt;();</span>

	/**
	 * The known alternatives for the given original table. Creates the
	 * alternative in cache.
	 */
	private static TableAlternatives getAlternatives(String mainTable) {
<span class="fc" id="L306">		TableAlternatives nw = new TableAlternatives(mainTable);</span>
<span class="fc" id="L307">		TableAlternatives od = tablesAlternatives.putIfAbsent(mainTable, nw);</span>
<span class="fc bfc" id="L308" title="All 2 branches covered.">		return od == null ? nw : od;</span>
	}

	// For test purpose
	static void clearAlternativesCache() {
<span class="fc" id="L313">		tablesAlternatives.clear();</span>
<span class="fc" id="L314">	}</span>

	/**
	 * Adds an alternative to an original table.
	 * 
	 * @param mainTable
	 *            the original table
	 * @param postfix
	 *            the (possibly new) alternative postfix (can be &quot;&quot;)
	 * @param store
	 *            the store in which storing alternative table ; should be the
	 *            store for a class having {@link #mainTable} as original table
	 * @see TableAlternatives#addPostfix(String, Store)
	 */
	private static void registerPostfix(String mainTable, String postfix,
			Store store) {
<span class="fc" id="L330">		getAlternatives(mainTable).addPostfix(postfix, store);</span>
<span class="fc" id="L331">	}</span>

	/**
	 * Checks whether a class is stored to a table federation.
	 */
	public static boolean isFederated(Class&lt;? extends PersistingElement&gt; clazz) {
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">		return clazz != null</span>
<span class="fc" id="L338">				&amp;&amp; PersistingElementOverFederatedTable.class</span>
<span class="fc bfc" id="L339" title="All 2 branches covered.">						.isAssignableFrom(clazz)</span>
<span class="fc" id="L340">				&amp;&amp; clazz.getAnnotation(Persisting.class).federated()</span>
<span class="pc bpc" id="L341" title="1 of 2 branches missed.">						.isFederated();</span>
	}
	
//	/**
//	 * Class used to perform an operation over necessary table postfixes until goal is reached.
//	 * Operation is retried on other necessary postfixes in case of unconvincing result
//	 * as determined by {@link #isInexistingValue(Object)}.
//	 * First convincing value is sent.
//	 * @param &lt;T&gt; the type of the expected result
//	 */
//	private abstract static class PerformWithRetries&lt;T&gt; {
//		
//		public PerformWithRetries() {}
//		
//		/**
//		 * The operation to perform on a given postfix
//		 */
//		public abstract T perform(String postfix);
//		
//		/**
//		 * Value sent when element on which action is performed does not exist
//		 */
//		public abstract T inexistingValue();
//		
//		/**
//		 * Kind of the performed operation
//		 */
//		public abstract ReadWrite getOperationNature();
//		
//		/**
//		 * Checks whether this value corresponds to a value typical from an inexisting element
//		 */
//		public boolean isInexistingValue(T value) {
//			T inexisting = inexistingValue();
//			return inexisting == null ? value == null : inexisting == value || inexisting.equals(value);
//		}
//		
//		public T performWithRetries(PersistingElementOverFederatedTable self) {
//			boolean locationJustFound; 
//			if (self.tablePostfix == null) {
//				if (self.findTableLocation(this.getOperationNature())) {
//					locationJustFound = true;
//				} else {
//					// We've just found that this element does not exist
//					return inexistingValue();
//				}
//			} else {
//				locationJustFound = false;
//			}
//			
//			LinkedList&lt;String&gt; toBeTested = new LinkedList&lt;String&gt;();
//			// First to be tested is the known localtion
//			toBeTested.addFirst(self.tablePostfix);
//			if (!locationJustFound) {
//				// Adding other location only in case we did not just test location
//				switch(self.getFederatedMode().getConsistency(this.getOperationNature())) {
//				case NONE:
//					// Nothing but known location
//					break;
//				case CONSISTENT_WITH_LEGACY:
//					// Should also check computed postfix and legacy table
//					String computedPostfix = self.getTablePostfix();
//					if (!toBeTested.contains(computedPostfix))
//						toBeTested.addLast(computedPostfix);
//					if (!toBeTested.contains(&quot;&quot;))
//						toBeTested.addLast(&quot;&quot;);
//				case CONSISTENT:
//					// Should check all
//					for (String postfix : self.getPossiblePostfixesWithAnUpdate(self.getStore())) {
//						if (!toBeTested.contains(postfix))
//							toBeTested.addLast(postfix);
//					}
//				}
//			}
//
//			for (String postfix : toBeTested) {
//				T ret = this.perform(postfix);
//				if (!this.isInexistingValue(ret)) {
//					// Great, we found a nice value !
//					// Enforcing proper postfix is registered
//					self.setTablePostfix(postfix, self.getStore());
//					// Returning nice value
//					return ret;
//				}
//			}
//			
//			return this.inexistingValue();
//		}
//	}

	/**
	 * An action that is automatically executed on each postfixes for a given table.
	 * @param &lt;T&gt; the type of the expected result
	 */
<span class="fc" id="L435">	private static abstract class GlobalAction&lt;T&gt; {</span>
		
<span class="fc" id="L437">		private static final ExecutorService executor = new ThreadPoolExecutor(</span>
<span class="fc" id="L438">				0, Integer.MAX_VALUE,</span>
<span class="fc" id="L439">                10L, TimeUnit.SECONDS,</span>
<span class="fc" id="L440">                new SynchronousQueue&lt;Runnable&gt;(),</span>
<span class="fc" id="L441">                new ThreadFactory()  {</span>

			@Override
			public Thread newThread(Runnable r) {
<span class="fc" id="L445">				return new Thread(r,&quot;n-orm federated executor&quot;);</span>
			}
			
		});
		
<span class="fc" id="L450">		protected GlobalAction() {}</span>

		/**
		 * Runs the query on one possible alternative table
		 */
		protected abstract T localRun(String mainTable, String postfix);

		/**
		 * Merging two results for different alternative table into a single
		 * one. Order in which results are merged is unknown.
		 * 
		 * @param lhs
		 *            either result for the first table or the previously
		 *            aggregated result.
		 */
		protected abstract T add(T lhs, T rhs);
		
		/**
		 * The default value returned by {@link #globalRun(String, Store, Constraint)}
		 * in case table does not exists.
		 */
		protected abstract T emptyValue();

		private Callable&lt;T&gt; createLocalAction(final String mainTable,
				final String postfix, final AtomicInteger running) {
			// Waiting till there are not too many threads executing
<span class="pc" id="L476">			synchronized(running) {</span>
<span class="fc" id="L477">				running.decrementAndGet();</span>
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">				while (running.get() &lt; 0)</span>
					try {
<span class="nc" id="L480">						running.wait();</span>
<span class="nc" id="L481">					} catch (InterruptedException e) {</span>
<span class="nc" id="L482">						e.printStackTrace();</span>
					}
			}
			
<span class="fc" id="L486">			return new Callable&lt;T&gt;() {</span>

				@Override
				public T call() throws Exception {
					try {
						
<span class="fc" id="L492">						return localRun(mainTable, postfix);</span>
						
<span class="nc" id="L494">					} finally {</span>
					
						// Letting waiting thread run
<span class="pc" id="L497">						synchronized(running) {</span>
<span class="pc" id="L498">							running.incrementAndGet();</span>
<span class="pc" id="L499">							running.notify();</span>
						}
<span class="nc" id="L501">					}</span>
				}

			};
		}

		/**
		 * Runs {@link #localRun(String) the action} on all referenced
		 * alternative tables (including main table) and
		 * {@link #add(Object, Object) aggregates} results.
		 * Returns null in case no postfix alternative is found. 
		 * 
		 * @param c a constraint where table postfix might have been set (can be null)
		 */
		public T globalRun(String mainTable, Store store, Constraint c) {

<span class="fc" id="L517">			TableAlternatives alts = getAlternatives(mainTable);</span>
			// Making sure we are aware of all possible alternative tables
<span class="fc" id="L519">			alts.updateAlternatives(store);</span>

<span class="fc bfc" id="L521" title="All 4 branches covered.">			if (c != null &amp;&amp; (c instanceof ConstraintWithPostfix)) {</span>
				// Table postfix was set in the query
				// computing only for this one 
<span class="fc" id="L524">				String postfix = ((ConstraintWithPostfix) c).getPostfix();</span>
				
<span class="pc bpc" id="L526" title="1 of 2 branches missed.">				if (!alts.getPostfixes().contains(postfix)) {</span>
					// Unknown postfix...
<span class="nc bnc" id="L528" title="All 2 branches missed.">					if (store.hasTable(mainTable+postfix)) {</span>
						// But still, it exists
<span class="nc" id="L530">						registerPostfix(mainTable, postfix, store);</span>
					} else {
						// Table does not exist ; returning empty value
<span class="nc" id="L533">						return this.emptyValue();</span>
					}
				}
<span class="fc" id="L536">				return this.localRun(mainTable, postfix);</span>
			}
			
			// No need to worry too much in case no postfix exists...
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">			if (alts.getPostfixes().isEmpty())</span>
<span class="nc" id="L541">				return this.emptyValue();</span>

<span class="fc" id="L543">			AtomicInteger running = new AtomicInteger(getParallelGlobalSearch());</span>
			
<span class="fc" id="L545">			Set&lt;Future&lt;T&gt;&gt; results = new HashSet&lt;Future&lt;T&gt;&gt;();</span>
<span class="fc bfc" id="L546" title="All 2 branches covered.">			for (final String post : alts.getPostfixes()) {</span>
<span class="fc" id="L547">				results.add(executor.submit(this.createLocalAction(mainTable, post, running)));</span>
			}

			// Aggregating results into one single result
<span class="fc" id="L551">			T ret = null;</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">			for (Future&lt;T&gt; res : results) {</span>
				try {
<span class="fc bfc" id="L554" title="All 2 branches covered.">					ret = ret == null ? res.get() : this.add(ret, res.get());</span>
<span class="nc" id="L555">				} catch (InterruptedException e) {</span>
<span class="nc" id="L556">					throw new DatabaseNotReachedException(e);</span>
<span class="nc" id="L557">				} catch (ExecutionException e) {</span>
<span class="nc" id="L558">					throw new DatabaseNotReachedException(e);</span>
				}
			}

<span class="fc" id="L562">			return ret;</span>
		}
	}

	/**
	 * The postfix for tables ; null if table is not known yet. This persisting
	 * element is actually stored in the table given by
	 * {@link PersistingMixin#getTable(Class)} postfixed with tablePostfix. If
	 * known, alters result for {@link PersistingElement#getTable()};
	 * 
	 * @see Persisting#table()
	 */
	private transient String PersistingElementOverFederatedTable.tablePostfix;

	/**
	 * Sets table postfix as it is discovered.
	 * 
	 * @param postfix
	 * @param store
	 *            null value means that table won't be registered (even not
	 *            cached)
	 * @throws IllegalStateException
	 *             if a different postfix is already known
	 * @throws IllegalStateException
	 *             if {@link Persisting#federated()} stated to check for table
	 *             postfix consistency over time and result for
	 *             {@link PersistingElementOverFederatedTable#getTablePostfix()}
	 *             provides a different result
	 */
	private void PersistingElementOverFederatedTable.setTablePostfix(
			String postfix, Store store) {
<span class="fc bfc" id="L593" title="All 2 branches covered.">		if (postfix == null) {</span>
<span class="fc" id="L594">			this.tablePostfix = null;</span>
<span class="fc" id="L595">			return;</span>
		}

<span class="fc" id="L598">		String oldPostfix = this.tablePostfix;</span>
<span class="fc" id="L599">		this.tablePostfix = postfix;</span>
<span class="fc" id="L600">		this.checkTablePostfixHasNotChanged();</span>
<span class="pc bpc" id="L601" title="1 of 4 branches missed.">		if (oldPostfix != null &amp;&amp; !oldPostfix.equals(this.tablePostfix)) {</span>
<span class="nc" id="L602">			throw new IllegalStateException(&quot;Found &quot; + this + &quot; from table &quot;</span>
<span class="nc" id="L603">					+ ((PersistingElement)this).getTable() + this.tablePostfix + &quot; with postfix &quot;</span>
<span class="nc" id="L604">					+ this.tablePostfix + &quot; while another postfix &quot;</span>
<span class="nc" id="L605">					+ oldPostfix + &quot; was registered&quot;);</span>
		}
<span class="fc bfc" id="L607" title="All 2 branches covered.">		if (store != null)</span>
<span class="fc" id="L608">			registerPostfix(((PersistingElement)this).getTable(), this.tablePostfix, store);</span>
<span class="fc" id="L609">	}</span>

	// jut to be sure
	declare error: set(* PersistingElementOverFederatedTable.tablePostfix) &amp;&amp; !withincode(private void PersistingElementOverFederatedTable.setTablePostfix(..)) : &quot;Avoid setting this attribute directly ; use setTablePostfix(String postfix, Store store) instead&quot;;

	public String PersistingElementOverFederatedTable.getActualTable() {
<span class="pc bpc" id="L615" title="1 of 2 branches missed.">		if (this.tablePostfix == null)</span>
<span class="nc" id="L616">			return null;</span>
<span class="fc" id="L617">		return ((PersistingElement)this).getTable() + this.tablePostfix;</span>
	}

	private transient FederatedMode PersistingElementOverFederatedTable.federatedMode = null;

	/**
	 * The federated mode for this persisting element.
	 */
	public FederatedMode PersistingElementOverFederatedTable.getFederatedMode() {
<span class="fc bfc" id="L626" title="All 2 branches covered.">		if (this.federatedMode == null) {</span>
<span class="fc" id="L627">			this.federatedMode = this.getClass()</span>
<span class="fc" id="L628">					.getAnnotation(Persisting.class).federated();</span>
		}
<span class="fc" id="L630">		return this.federatedMode;</span>
	}

	/**
	 * Overloads the federated mode for this specific element. You cannot set
	 * the federated mode to {@link FederatedMode#NONE}. This method has only an
	 * impact before actual postfix for the element is found, i.e. before any
	 * operation such as {@link PersistingElement#store()} or
	 * {@link PersistingElement#activate(String...)} is called.
	 * 
	 * @throws IllegalArgumentException
	 *             if mode is set to {@link FederatedMode#NONE}.
	 */
	public void PersistingElementOverFederatedTable.setFederatedMode(
			FederatedMode mode) {
<span class="nc bnc" id="L645" title="All 2 branches missed.">		if (FederatedMode.NONE.equals(mode))</span>
<span class="nc" id="L646">			throw new IllegalArgumentException(&quot;Cannot set federated mode to &quot;</span>
<span class="nc" id="L647">					+ mode + &quot; on &quot; + this);</span>
<span class="nc" id="L648">		this.federatedMode = mode;</span>
<span class="nc" id="L649">	}</span>

	/**
	 * The list of tables where to find this object from what we can guess in
	 * order of probability.
	 */
	private List&lt;String&gt; PersistingElementOverFederatedTable.getKnownPossiblePostfixes() {
<span class="fc" id="L656">		List&lt;String&gt; ret = new LinkedList&lt;String&gt;();</span>
		// Table for this object is already known
<span class="pc bpc" id="L658" title="1 of 2 branches missed.">		if (this.tablePostfix != null) {</span>
<span class="nc" id="L659">			ret.add(this.tablePostfix);</span>
<span class="nc" id="L660">			return ret;</span>
		}

<span class="fc" id="L663">		String mainTable = ((PersistingElement)this).getTable();</span>
<span class="fc" id="L664">		TableAlternatives alternatives = getAlternatives(mainTable);</span>
<span class="fc" id="L665">		Set&lt;String&gt; possibilities = new TreeSet&lt;String&gt;(</span>
<span class="fc" id="L666">				alternatives.getPostfixes());</span>

		// First, asks postfix if the element already knows
<span class="fc" id="L669">		String computedPostfix = this.getTablePostfix();</span>
<span class="fc" id="L670">		ret.add(computedPostfix);</span>
<span class="fc" id="L671">		possibilities.remove(computedPostfix);</span>

		// Otherwise, let's see main table
<span class="pc bpc" id="L674" title="1 of 4 branches missed.">		if(possibilities.remove(&quot;&quot;) &amp;&amp; !ret.contains(&quot;&quot;)) {</span>
<span class="fc" id="L675">			ret.add(&quot;&quot;);</span>
		}

		// And then all other known tables in alphabetical order
<span class="fc" id="L679">		ret.addAll(possibilities);</span>

<span class="fc" id="L681">		return ret;</span>
	}

	/**
	 * The list of tables where to find this object when it failed to be found
	 * from tables given by
	 * {@link PersistingElementOverFederatedTable#getKnownPossibleTables()} ;
	 * only previously unknown tables from from the store are returned by this
	 * function
	 * 
	 * @see TableAlternatives#updateAlternatives(Store)
	 */
	private Collection&lt;String&gt; PersistingElementOverFederatedTable.getPossiblePostfixesWithAnUpdate(
			Store store) {
<span class="fc" id="L695">		TableAlternatives ta = getAlternatives(((PersistingElement)this).getTable());</span>
<span class="fc" id="L696">		ta.updateAlternatives(store);</span>
<span class="fc" id="L697">		return ta.getPostfixes(); </span>
	}

	/**
	 * Checks whether
	 * {@link PersistingElementOverFederatedTable#getTablePostfix()} is
	 * consistent with the known table postfix.
	 * 
	 * @throws IllegalStateException
	 *             in case {@link Persisting#federated()} states table postfix
	 *             computation should be checked and is different from known
	 *             postfix
	 * @see FederatedMode#isCheckForChangingPostfix()
	 */
	private void PersistingElementOverFederatedTable.checkTablePostfixHasNotChanged() {
<span class="fc" id="L712">		FederatedMode fm = this.getFederatedMode();</span>
<span class="pc bpc" id="L713" title="1 of 4 branches missed.">		if (this.tablePostfix != null &amp;&amp; fm.isCheckForChangingPostfix()) {</span>
			// Let's check whether a new computation for table postfix changes
			// its value...
<span class="fc" id="L716">			String computedPostfix = this.getTablePostfix();</span>
<span class="fc bfc" id="L717" title="All 2 branches covered.">			if (!this.tablePostfix.equals(computedPostfix)) {</span>
				// Could still be forgiven in legacy mode
<span class="pc bpc" id="L719" title="1 of 2 branches missed.">				if (this.tablePostfix.length() != 0)</span>
<span class="fc" id="L720">					throw new IllegalStateException(this</span>
<span class="fc" id="L721">							+ &quot; already registered in table &quot; + ((PersistingElement)this).getTable()</span>
<span class="fc" id="L722">							+ &quot; with postfix &quot; + this.tablePostfix</span>
<span class="fc" id="L723">							+ &quot; while computed postfix states now &quot;</span>
<span class="fc" id="L724">							+ computedPostfix);</span>
			}
		}
<span class="fc" id="L727">	}</span>
	
	/**
	 * Creates a temporary element of the given class, for the given table postfix.
	 * Element is removed from the cache.
	 */
	private static PersistingElementOverFederatedTableWithMerge createTemporaryElement(
			Class&lt;? extends PersistingElementOverFederatedTableWithMerge&gt; clazz,
			Store store, String id, String postfix, Set&lt;String&gt; families, ColumnFamilyData values) {
<span class="fc" id="L736">		KeyManagement km = KeyManagement.getInstance();</span>
		// Removing any cached element so that created one is really new
<span class="fc" id="L738">		km.unregister(clazz.asSubclass(PersistingElement.class), id);</span>
		
		// Creating element
<span class="fc" id="L741">		PersistingElementOverFederatedTableWithMerge elt =</span>
<span class="fc" id="L742">				(PersistingElementOverFederatedTableWithMerge)km.createElement(clazz, id);</span>
		// Not keeping element in cache (it's temporary)
<span class="fc" id="L744">		km.unregister((PersistingElement)elt);</span>
<span class="fc bfc" id="L745" title="All 2 branches covered.">		if (families != null) {</span>
			// In case we already know some information
<span class="fc" id="L747">			((PersistingElement)elt).activateFromRawData(families, values);</span>
		}
		// Table postfix
<span class="fc" id="L750">		((PersistingElementOverFederatedTable)elt).setTablePostfix(postfix, store);</span>
		
<span class="fc" id="L752">		return elt;</span>
	}
	
	/**
	 * Tries to repair an inconsistency by merging the given element into this element.
	 * In case of success, this element is stored and the given element deleted. 
	 */
	private void PersistingElementOverFederatedTableWithMerge.repairInconsistencyByMerging(
			PersistingElementOverFederatedTableWithMerge elt) {
<span class="pc bpc" id="L761" title="2 of 4 branches missed.">		assert this != elt;</span>
<span class="pc bpc" id="L762" title="2 of 4 branches missed.">		assert this.getClass().equals(elt.getClass());</span>
<span class="pc bpc" id="L763" title="2 of 4 branches missed.">		assert ((PersistingElementOverFederatedTable)this).tablePostfix != null;</span>
<span class="pc bpc" id="L764" title="2 of 4 branches missed.">		assert ((PersistingElementOverFederatedTable)elt).tablePostfix != null;</span>
<span class="pc bpc" id="L765" title="2 of 4 branches missed.">		assert !((PersistingElementOverFederatedTable)this).tablePostfix.equals(((PersistingElementOverFederatedTable)elt).tablePostfix);</span>

<span class="fc" id="L767">		KeyManagement km = KeyManagement.getInstance();</span>
		// There is no official element for this id yet (as there is an inconsistency)
<span class="fc" id="L769">		km.unregister((PersistingElement)this);</span>
		
		// Trying to repair by merging
		try {
<span class="fc" id="L773">			this.mergeWith(elt);</span>
<span class="nc" id="L774">		} catch (Exception x) {</span>
			// Couldn't merge :(
<span class="nc" id="L776">			throw new IllegalStateException(</span>
<span class="nc" id="L777">					&quot;Found unmergeable duplicate data with id &quot; + ((PersistingElement)this).getIdentifier()</span>
<span class="nc" id="L778">					+ &quot; in tables '&quot; + ((PersistingElement)this).getTable()</span>
<span class="nc" id="L779">					+ &quot; with postfixes &quot; + ((PersistingElementOverFederatedTable)this).tablePostfix</span>
<span class="nc" id="L780">					+ &quot;' and '&quot; + ((PersistingElementOverFederatedTable)elt).tablePostfix + '\'', x);</span>
		}
		
		// Immediately storing this and deleting other element once merged
<span class="fc" id="L784">		((PersistingElement)this).store();</span>
		// Can't delete using elt.delete()
		// &quot;this&quot; exists and makes elt believe that it still exists after delete (assertion fails)
<span class="fc" id="L787">		((PersistingElement)this).getStore().delete(</span>
<span class="fc" id="L788">				new MetaInformation().forElement((PersistingElement)elt).withPostfixedTable(((PersistingElement)elt).getTable(), ((PersistingElementOverFederatedTable)elt).tablePostfix),</span>
<span class="fc" id="L789">				((PersistingElementOverFederatedTable)elt).getActualTable(), ((PersistingElement)elt).getIdentifier());</span>
		// Consistency issue repaired :)
		
		// this is now the officiel version for this id
<span class="fc" id="L793">		km.register((PersistingElement)this);</span>
<span class="fc" id="L794">	}</span>

	/**
	 * Sets the table postfix in case it is not known by searching this
	 * element's identifer across all possible tables. Tables are explored in
	 * order of probability: with computed table postfix, with no postfix, with
	 * already known postfixes for the original table, will all possible
	 * postfixes (not already tested) taken from the store (see
	 * {@link TableAlternatives#updateAlternatives(Store)}).
	 * 
	 * @return whether this table was newly found
	 */
	private boolean PersistingElementOverFederatedTable.findTableLocation(
			final ReadWrite mode) {
<span class="fc bfc" id="L808" title="All 2 branches covered.">		if (this.tablePostfix != null) {</span>
<span class="fc" id="L809">			this.checkTablePostfixHasNotChanged();</span>
<span class="fc" id="L810">			return false;</span>
		}
<span class="fc" id="L812">		String computedPostfix = this.getTablePostfix();</span>
<span class="fc" id="L813">		Consistency consistencyLevel = this.getFederatedMode().getConsistency(mode);</span>

<span class="fc" id="L815">		final Store store = ((PersistingElement)this).getStore();</span>

<span class="fc" id="L817">		final String mainTable = ((PersistingElement)this).getTable();</span>
<span class="fc" id="L818">		final String id = ((PersistingElement)this).getIdentifier();</span>
<span class="pc bpc" id="L819" title="1 of 4 branches missed.">		switch (consistencyLevel) {</span>
		case NONE:
			// Trusting computed value
<span class="pc bpc" id="L822" title="1 of 2 branches missed.">			this.setTablePostfix(computedPostfix, mode.isRead() ? null : store);</span>
<span class="fc" id="L823">			return true;</span>
			
		case CONSISTENT_WITH_LEGACY:
			// Soft consistency ; only testing expected table and legacy

			// First trying with expected table
<span class="pc bpc" id="L829" title="1 of 2 branches missed.">			if (this.testTableLocation(mainTable, computedPostfix, id, store))</span>
<span class="nc" id="L830">				return true;</span>

			// Then trying with legacy table (if different)
<span class="pc bpc" id="L833" title="1 of 2 branches missed.">			if (!&quot;&quot;.equals(computedPostfix)</span>
<span class="pc bpc" id="L834" title="1 of 2 branches missed.">				&amp;&amp; FederatedTableManagement.getAlternatives(((PersistingElement)this).getTable()).legacyExists(store)</span>
<span class="nc bnc" id="L835" title="All 2 branches missed.">				&amp;&amp; this.testTableLocation(mainTable, &quot;&quot;, id, store))</span>
<span class="nc" id="L836">				return true;</span>
			
			break;
			
		case CONSISTENT:
			
<span class="fc" id="L842">			Set&lt;String&gt; tested = new HashSet&lt;String&gt;();</span>
<span class="fc bfc" id="L843" title="All 2 branches covered.">			for (String post : this.getKnownPossiblePostfixes()) {</span>
<span class="pc bpc" id="L844" title="1 of 4 branches missed.">				if (tested.add(post) &amp;&amp; this.testTableLocation(mainTable, post, id, store))</span>
<span class="fc" id="L845">					return true;</span>
			}
			// No found yet ; querying possible alternatives from store
<span class="fc bfc" id="L848" title="All 2 branches covered.">			for (String post : this.getPossiblePostfixesWithAnUpdate(store)) {</span>
<span class="fc bfc" id="L849" title="All 4 branches covered.">				if (tested.add(post) &amp;&amp; this.testTableLocation(mainTable, post, id, store))</span>
<span class="fc" id="L850">					return true;</span>
			}
			
//			// Hard consistency ; checking all possible tables in parallel
//			GlobalAction&lt;Set&lt;String&gt;&gt; tableSearch = new GlobalAction&lt;Set&lt;String&gt;&gt;() {
//				
//				@Override
//				protected Set&lt;String&gt; localRun(String mainTable, String postfix) {
//					return store.exists(null, mainTable	+ postfix, id) ? 
//								Collections.singleton(postfix)
//							: 	Collections.&lt;String&gt;emptySet();
//				}
//				
//				@Override
//				protected Set&lt;String&gt; emptyValue() {
//					return Collections.emptySet();
//				}
//
//				@Override
//				protected Set&lt;String&gt; add(Set&lt;String&gt; lhs, Set&lt;String&gt; rhs) {
//					// Using a tree set so that found postfixes are sorted in alphabetica order
//					// This makes all processes result in the same and predictible way
//					if (!(lhs instanceof TreeSet))
//						lhs = new TreeSet&lt;String&gt;(lhs);
//					lhs.addAll(rhs);
//					return lhs;
//				}
//				
//			};
//			
//			Set&lt;String&gt; found = tableSearch.globalRun(mainTable, store, null);
//			if (found.size() &gt; 1) {
//				// Inconsistency detected ; repairing
//				
//				// Repair possible only if class for this object makes it possible
//				if (! (this instanceof PersistingElementOverFederatedTableWithMerge))
//					throw new DatabaseNotReachedException(
//							&quot;Inconsistency detected: found element &quot; + this
//							+ &quot; in tables &quot; + mainTable + &quot; with the following postfixes &quot; + found
//							+ &quot; ; make &quot; + this.getClass().getName()
//							+ &quot; implement &quot; + PersistingElementOverFederatedTableWithMerge.class.getName()
//							+ &quot; in order to recover&quot;);
//				
//				// Postfix of the final element
//				String targetPostfix;
//				if (found.remove(computedPostfix)) {
//					targetPostfix = computedPostfix;
//				} else {
//					// Taking the first postfix in alphabetical order
//					// so that any process will result in the same target postfix
//					targetPostfix = ((NavigableSet&lt;String&gt;)found).first();
//				}
//				this.setTablePostfix(targetPostfix, store);
//
//				KeyManagement km = KeyManagement.getInstance();
//				// Forgetting about this element in the cache
//				km.unregister(this);
//				
//				// Merging other elements into this object
//				for (String postfix : found) {
//					PersistingElementOverFederatedTableWithMerge elt =
//							FederatedTableManagement.createTemporaryElement(
//									this.getClass().asSubclass(PersistingElementOverFederatedTableWithMerge.class),
//									this.getStore(),
//									this.getIdentifier(),
//									postfix,
//									null, null);
//					((PersistingElementOverFederatedTableWithMerge)this).repairInconsistencyByMerging(elt);
//				}
//				
//				km.register(this);
//				
//				assert tableSearch.globalRun(mainTable, store, null).size() == 1;
//				
//				return true;
//				
//			} else if (found.size() == 1) {
//				this.setTablePostfix(found.iterator().next(), store);
//				return true;
//			}
			
			break;
			
		}

		// Still not found ; setting postfix to computed value
		// Only registering in case we are sure table exists (or about to)
<span class="fc bfc" id="L937" title="All 2 branches covered.">		this.setTablePostfix(computedPostfix, mode.isRead() ? null : store);</span>
<span class="fc" id="L938">		return false;</span>
	}

	private boolean PersistingElementOverFederatedTable.testTableLocation(
		String mainTable, String postfix, String id, Store store) {
<span class="fc bfc" id="L943" title="All 2 branches covered.">		if (store.exists(new MetaInformation().forElement((PersistingElement)this)</span>
<span class="fc" id="L944">				.withPostfixedTable(mainTable, postfix), mainTable</span>
<span class="fc" id="L945">				+ postfix, id)) {</span>
<span class="fc" id="L946">			this.setTablePostfix(postfix, store);</span>
<span class="fc" id="L947">			return true;</span>
		}
<span class="fc" id="L949">		return false;</span>
	}

	// getTablePostfix might return null ; we'll consider it is equivalent to
	// empty postfix
	String around():
		call(String PersistingElementOverFederatedTable+.getTablePostfix())
		&amp;&amp; within(FederatedTableManagement) {
<span class="fc" id="L957">		String ret = proceed();</span>
<span class="fc bfc" id="L958" title="All 2 branches covered.">		return ret == null ? &quot;&quot; : ret;</span>
	}

	// Generic pointcut to state where things have to be woven
	pointcut inNOrm(): 
		within(com.googlecode.n_orm..*) &amp;&amp; !within(*..*Test) &amp;&amp; !within(FederatedTableManagement) &amp;&amp; !within(DelegatingStore+);

	// ===================================
	// element-level operations
	// ===================================

	// Store
	void around(MetaInformation meta, String table, Store store):
		call(void Store+.storeChanges(..))
		&amp;&amp; inNOrm()
		&amp;&amp; target(store)
		&amp;&amp; args(meta, table, ..)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L976">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L977">				.getElement();</span>
<span class="nc" id="L978">		self.findTableLocation(ReadWrite.WRITE);</span>
<span class="nc" id="L979">		registerPostfix(table, self.tablePostfix, store);</span>
<span class="nc" id="L980">		proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L981">				+ self.tablePostfix, store);</span>
<span class="nc" id="L982">	}</span>

	// Activate
	ColumnFamilyData around(final MetaInformation meta, final String table, final String id, final Set&lt;String&gt; families, final Store store):
		call(ColumnFamilyData Store.get(MetaInformation,String,String,Set&lt;String&gt;))
		&amp;&amp; inNOrm()
		&amp;&amp; args(meta, table, id, families)
		&amp;&amp; target(store)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L991">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L992">				.getElement();</span>
		
//		// Testing possible tables depending on consistency
//		return new PerformWithRetries&lt;ColumnFamilyData&gt;() {
//
//			@Override
//			public ColumnFamilyData perform(String postfix) {
//				return store.get(meta.withPostfixedTable(table, postfix), table+postfix, id, families);
//			}
//
//			@Override
//			public ColumnFamilyData inexistingValue() {
//				return null;
//			}
//
//			@Override
//			public ReadWrite getOperationNature() {
//				return ReadWrite.READ;
//			}
//		}.performWithRetries(self);
			
<span class="nc bnc" id="L1013" title="All 2 branches missed.">		if (self.tablePostfix == null</span>
<span class="nc bnc" id="L1014" title="All 2 branches missed.">				&amp;&amp; !self.findTableLocation(ReadWrite.READ))</span>
			// We've just found that this element does not exist
<span class="nc" id="L1016">			return null;</span>
<span class="nc" id="L1017">		return proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1018">				+ self.tablePostfix, id, families, store);</span>
	}

	// Exists
	boolean around(final MetaInformation meta, final String table, final String id, final Store store):
		call(boolean Store.exists(MetaInformation, String, String))
		&amp;&amp; inNOrm()
		&amp;&amp; args(meta, table, id)
		&amp;&amp; target(store)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L1028">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L1029">				.getElement();</span>
		
//		return new PerformWithRetries&lt;Boolean&gt;() {
//
//			@Override
//			public Boolean perform(String postfix) {
//				return store.exists(meta.withPostfixedTable(table, postfix), table+postfix, id);
//			}
//
//			@Override
//			public Boolean inexistingValue() {
//				return false;
//			}
//
//			@Override
//			public ReadWrite getOperationNature() {
//				return ReadWrite.READ;
//			}
//		}.performWithRetries(self);
		
<span class="nc bnc" id="L1049" title="All 2 branches missed.">		if (self.tablePostfix == null</span>
<span class="nc bnc" id="L1050" title="All 2 branches missed.">				&amp;&amp; !self.findTableLocation(ReadWrite.READ))</span>
			// We've just found that this element does not exist
<span class="nc" id="L1052">			return false;</span>
<span class="nc" id="L1053">		return proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1054">				+ self.tablePostfix, id, store);</span>
	}

	// Delete
	void around(final MetaInformation meta, final String table, final String id, final Store store):
		call(void Store+.delete(..))
		&amp;&amp; inNOrm()
		&amp;&amp; target(store)
		&amp;&amp; args(meta, table, id)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L1064">		final PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L1065">				.getElement();</span>
		
//		new PerformWithRetries&lt;Void&gt;() {
//
//			@Override
//			public Void perform(String postfix) {
//				store.delete(meta.withPostfixedTable(table, postfix), table+postfix, id);
//				return null;
//			}
//
//			@Override
//			public Void inexistingValue() {
//				// Also forces performing on all necessary tables
//				return null;
//			}
//			
//			@Override
//			public ReadWrite getOperationNature() {
//				return ReadWrite.READ_OR_WRITE;
//			}
//		}.performWithRetries(self);
//		self.setTablePostfix(null, null);
		
<span class="nc" id="L1088">		self.findTableLocation(ReadWrite.READ_OR_WRITE);</span>
<span class="nc" id="L1089">		proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1090">				+ self.tablePostfix, id, store);</span>
<span class="nc" id="L1091">		self.setTablePostfix(null, null);</span>

//		// Checking other tables, depending on consistency level
//		while(self.findTableLocation(ReadWrite.READ_OR_WRITE)) {
//			// Found element in yet another table ; deleting 
//			store.delete(meta.withPostfixedTable(table, self.tablePostfix),
//					self.getActualTable(), id);
//			self.setTablePostfix(null, null);
//		}
<span class="nc" id="L1100">	}</span>

	// ===================================
	// family-level operations
	// ===================================

	// Exists
	boolean around(MetaInformation meta, String table):
		call(boolean Store.exists(MetaInformation, String, String, String))
		&amp;&amp; inNOrm()
		&amp;&amp; args(meta, table, ..)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L1112">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L1113">				.getElement();</span>
<span class="nc bnc" id="L1114" title="All 2 branches missed.">		if (self.tablePostfix == null</span>
<span class="nc bnc" id="L1115" title="All 2 branches missed.">				&amp;&amp; !self.findTableLocation(ReadWrite.READ))</span>
			// We've just found that this element does not exist
<span class="nc" id="L1117">			return false;</span>
<span class="nc" id="L1118">		return proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1119">				+ self.tablePostfix);</span>
	}

	// Get column
	byte[] around(MetaInformation meta, String table):
		call(byte[] Store.get(MetaInformation, String, String, String, String))
		&amp;&amp; inNOrm()
		&amp;&amp; args(meta, table, ..)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L1128">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L1129">				.getElement();</span>
<span class="nc bnc" id="L1130" title="All 2 branches missed.">		if (self.tablePostfix == null</span>
<span class="nc bnc" id="L1131" title="All 2 branches missed.">				&amp;&amp; !self.findTableLocation(ReadWrite.READ))</span>
			// We've just found that this element does not exist
<span class="nc" id="L1133">			return null;</span>
<span class="nc" id="L1134">		return proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1135">				+ self.tablePostfix);</span>
	}

	// Get all columns
	Map&lt;String, byte[]&gt; around(MetaInformation meta, String table):
		(		call(Map&lt;String, byte[]&gt; Store.get(MetaInformation, String, String, String))
			||	call(Map&lt;String, byte[]&gt; Store.get(MetaInformation, String, String, String, Constraint))
		)
		&amp;&amp; inNOrm()
		&amp;&amp; args(meta, table, ..)
		&amp;&amp; if(meta != null &amp;&amp; meta.getElement() instanceof PersistingElementOverFederatedTable) {
<span class="nc" id="L1146">		PersistingElementOverFederatedTable self = (PersistingElementOverFederatedTable) meta</span>
<span class="nc" id="L1147">				.getElement();</span>
<span class="nc bnc" id="L1148" title="All 2 branches missed.">		if (self.tablePostfix == null</span>
<span class="nc bnc" id="L1149" title="All 2 branches missed.">				&amp;&amp; !self.findTableLocation(ReadWrite.READ))</span>
			// We've just found that this element does not exist
<span class="nc" id="L1151">			return null;</span>
<span class="nc" id="L1152">		return proceed(meta.withPostfixedTable(table, self.tablePostfix), table</span>
<span class="nc" id="L1153">				+ self.tablePostfix);</span>
	}

	// ===================================
	// global-level operations
	// ===================================

	// Count
	long around(final MetaInformation meta, final String table,
			final Constraint c, final Store store):
		call(long Store.count(MetaInformation, String, Constraint))
		&amp;&amp; inNOrm()
		&amp;&amp; target(store)
		&amp;&amp; args(meta, table, c) {
<span class="nc bnc" id="L1167" title="All 2 branches missed.">		Class&lt;? extends PersistingElement&gt; clazz = meta == null ? null : meta</span>
<span class="nc" id="L1168">				.getClazzNoCheck();</span>
<span class="nc bnc" id="L1169" title="All 2 branches missed.">		if (!isFederated(clazz)) {</span>
<span class="nc" id="L1170">			return proceed(meta, table, c, store);</span>
		}

<span class="pc" id="L1173">		return new GlobalAction&lt;Long&gt;() {</span>

			@Override
			protected Long localRun(String mainTable, String postfix) {
<span class="fc" id="L1177">				return store.count(new MetaInformation(meta)</span>
<span class="fc" id="L1178">						.withPostfixedTable(mainTable, postfix), mainTable</span>
<span class="fc" id="L1179">						+ postfix, c);</span>
			}
			
			@Override
			protected Long emptyValue() {
<span class="nc" id="L1184">				return 0l;</span>
			}

			@Override
			protected Long add(Long lhs, Long rhs) {
<span class="fc" id="L1189">				return lhs + rhs;</span>
			}
<span class="nc" id="L1191">		}.globalRun(table, store, c);</span>
	}

	/**
	 * A {@link Row} decorated with the table from which data was retrieved.
	 */
	private static class RowWithTable implements Row {
		private final String mainTable, tablePostfix;
		private final Row row;

		public RowWithTable(String mainTable, String tablePostfix, Row row) {
<span class="fc" id="L1202">			super();</span>
<span class="fc" id="L1203">			this.mainTable = mainTable;</span>
<span class="fc" id="L1204">			this.tablePostfix = tablePostfix;</span>
<span class="fc" id="L1205">			this.row = row;</span>
<span class="fc" id="L1206">		}</span>

		public String getMainTable() {
<span class="fc" id="L1209">			return mainTable;</span>
		}

		public String getTablePostfix() {
<span class="fc" id="L1213">			return tablePostfix;</span>
		}

		@Override
		public String getKey() {
<span class="fc" id="L1218">			return row.getKey();</span>
		}

		@Override
		public ColumnFamilyData getValues() {
<span class="fc" id="L1223">			return row.getValues();</span>
		}
	}

	/**
	 * A {@link CloseableIterator} decorated with the table from which keys are
	 * found. {@link #next() Returns} instances of {@link RowWithTable}.
	 */
	private static class CloseableKeyIteratorWithTable implements
			CloseableKeyIterator {
		private final String mainTable, tablePostfix;
		private final CloseableKeyIterator iterator;

		public CloseableKeyIteratorWithTable(String mainTable,
				String tablePostfix, CloseableKeyIterator iterator) {
<span class="fc" id="L1238">			super();</span>
<span class="fc" id="L1239">			this.mainTable = mainTable;</span>
<span class="fc" id="L1240">			this.tablePostfix = tablePostfix;</span>
<span class="fc" id="L1241">			this.iterator = iterator;</span>
<span class="fc" id="L1242">		}</span>

		public String getMainTable() {
<span class="fc" id="L1245">			return mainTable;</span>
		}

		public String getTablePostfix() {
<span class="fc" id="L1249">			return tablePostfix;</span>
		}

		@Override
		public void close() {
<span class="fc" id="L1254">			iterator.close();</span>
<span class="fc" id="L1255">		}</span>

		@Override
		public boolean hasNext() {
<span class="fc" id="L1259">			return iterator.hasNext();</span>
		}

		/**
		 * @return an instance of {@link RowWithTable}
		 */
		@Override
		public Row next() {
<span class="fc" id="L1267">			Row r = iterator.next();</span>
<span class="pc bpc" id="L1268" title="1 of 2 branches missed.">			return r == null ? null : new RowWithTable(this.getMainTable(),</span>
<span class="fc" id="L1269">					getTablePostfix(), r);</span>
		}

		@Override
		public void remove() {
<span class="nc" id="L1274">			iterator.remove();</span>
<span class="nc" id="L1275">		}</span>
		
		@Override
		public String toString() {
<span class="fc" id="L1279">			return &quot;iterator on table '&quot; + this.getMainTable() + &quot;' with postfix '&quot; + this.getTablePostfix() +'\'';</span>
		}

	}

	// Search
	CloseableKeyIterator around(final MetaInformation meta, final String table,
			final Constraint c, final int limit, final Set&lt;String&gt; families,
			final Store store):
		call(CloseableKeyIterator Store.get(MetaInformation, String, Constraint,int, Set&lt;String&gt;))
		&amp;&amp; inNOrm()
		&amp;&amp; target(store)
		&amp;&amp; args(meta, table, c, limit, families) {
<span class="nc bnc" id="L1292" title="All 2 branches missed.">		final Class&lt;? extends PersistingElement&gt; clazz = meta == null ? null : meta</span>
<span class="nc" id="L1293">				.getClazzNoCheck();</span>
<span class="nc bnc" id="L1294" title="All 2 branches missed.">		if (!isFederated(clazz)) {</span>
<span class="nc" id="L1295">			return proceed(meta, table, c, limit, families, store);</span>
		}

<span class="pc" id="L1298">		return new GlobalAction&lt;CloseableKeyIterator&gt;() {</span>

			@Override
			protected CloseableKeyIterator localRun(String mainTable,
					String postfix) {
<span class="fc" id="L1303">				return new CloseableKeyIteratorWithTable(mainTable, postfix,</span>
<span class="fc" id="L1304">						store.get(new MetaInformation(meta).withPostfixedTable(</span>
<span class="fc" id="L1305">								mainTable, postfix), mainTable + postfix, c,</span>
<span class="fc" id="L1306">								limit, families));</span>
			}
			
			@Override
			protected CloseableKeyIterator emptyValue() {
<span class="nc" id="L1311">				return new EmptyCloseableIterator();</span>
			}

			@Override
			protected CloseableKeyIterator add(CloseableKeyIterator lhs,
					CloseableKeyIterator rhs) {
<span class="pc bpc" id="L1317" title="1 of 2 branches missed.">				if (lhs == null)</span>
<span class="nc" id="L1318">					return rhs;</span>
<span class="fc bfc" id="L1319" title="All 2 branches covered.">				if (!(lhs instanceof AggregatingIterator)) {</span>
					
<span class="fc" id="L1321">					AggregatingIterator ret =</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">							PersistingElementOverFederatedTableWithMerge.class.isAssignableFrom(clazz) ?</span>
									// Aggregating iterator able to repair inconsistencies
<span class="fc" id="L1324">								new AggregatingIterator() {</span>
									@Override
									public Row merge(Row r1, CloseableKeyIterator it1, Row r2, CloseableKeyIterator it2) throws Exception {
										// Inconsistency detected, trying to repair
<span class="pc bpc" id="L1328" title="2 of 4 branches missed.">										assert r1 instanceof RowWithTable;</span>
<span class="pc bpc" id="L1329" title="2 of 4 branches missed.">										assert r2 instanceof RowWithTable;</span>
<span class="pc bpc" id="L1330" title="2 of 4 branches missed.">										assert r1.getKey().equals(r2.getKey());</span>
<span class="pc bpc" id="L1331" title="2 of 4 branches missed.">										assert table.equals(((RowWithTable)r1).getMainTable());</span>
<span class="pc bpc" id="L1332" title="2 of 4 branches missed.">										assert table.equals(((RowWithTable)r2).getMainTable());</span>
<span class="fc" id="L1333">										String post1 = ((CloseableKeyIteratorWithTable)it1).getTablePostfix();</span>
<span class="fc" id="L1334">										String post2 = ((CloseableKeyIteratorWithTable)it2).getTablePostfix();</span>
<span class="pc bpc" id="L1335" title="2 of 4 branches missed.">										assert post1 != null;</span>
<span class="pc bpc" id="L1336" title="2 of 4 branches missed.">										assert post2 != null;</span>
<span class="pc bpc" id="L1337" title="2 of 4 branches missed.">										assert !post1.equals(post2);</span>
<span class="fc" id="L1338">										KeyManagement km = KeyManagement.getInstance();</span>
										
										// Creating elements from r1 and r2
<span class="fc" id="L1341">										PersistingElementOverFederatedTableWithMerge elt1 =</span>
<span class="fc" id="L1342">												FederatedTableManagement.createTemporaryElement(</span>
<span class="fc" id="L1343">														clazz.asSubclass(PersistingElementOverFederatedTableWithMerge.class),</span>
<span class="fc" id="L1344">														store, r1.getKey(), post1,</span>
<span class="fc" id="L1345">														families, r1.getValues());</span>
<span class="fc" id="L1346">										PersistingElementOverFederatedTableWithMerge elt2 =</span>
<span class="fc" id="L1347">												FederatedTableManagement.createTemporaryElement(</span>
<span class="fc" id="L1348">														clazz.asSubclass(PersistingElementOverFederatedTableWithMerge.class),</span>
<span class="fc" id="L1349">														store, r2.getKey(), post2,</span>
<span class="fc" id="L1350">														families, r2.getValues());</span>
<span class="fc" id="L1351">										km.unregister((PersistingElement)elt1);</span>
<span class="fc" id="L1352">										km.unregister((PersistingElement)elt2);</span>
										
										// Checking hoped location from 1
<span class="fc" id="L1355">										String expectedTablePostFix = ((PersistingElementOverFederatedTable)elt1).getTablePostfix();</span>
<span class="pc bpc" id="L1356" title="1 of 2 branches missed.">										if (post2.equals(expectedTablePostFix)) {</span>
											// Swapping 1 and 2 as 2 is on the right place, even in 1's belief
<span class="nc" id="L1358">											PersistingElementOverFederatedTableWithMerge ptmp = elt2;</span>
<span class="nc" id="L1359">											elt2 = elt1;</span>
<span class="nc" id="L1360">											elt1 = ptmp;</span>
<span class="nc" id="L1361">											Row rtmp = r2;</span>
<span class="nc" id="L1362">											r2 = r1;</span>
<span class="nc" id="L1363">											r1 = rtmp;</span>
<span class="nc" id="L1364">											String stmp = post2;</span>
<span class="nc" id="L1365">											post2 = post1;</span>
<span class="nc" id="L1366">											post1 = stmp;</span>
										}
										
										// Actual repair
<span class="fc" id="L1370">										elt1.repairInconsistencyByMerging(elt2);</span>
										
										// Preparing row to be returned (could eventually be activated to elt1)
<span class="fc" id="L1373">										String post = post1;</span>
<span class="fc" id="L1374">										final String id = r1.getKey();</span>
										// Expected data ; empty if no family expected, otherwise to be grabbed from the (actual) store
<span class="fc" id="L1376">										final ColumnFamilyData data =</span>
<span class="fc bfc" id="L1377" title="All 2 branches covered.">											families == null ? new DefaultColumnFamilyData()</span>
<span class="fc" id="L1378">											: store.get(meta.withPostfixedTable(table, post), table+post, id, families);</span>
<span class="fc" id="L1379">										return new RowWithTable(table, post,</span>
<span class="fc" id="L1380">												new Row() {</span>
													
													@Override
													public ColumnFamilyData getValues() {
<span class="fc" id="L1384">														return data;</span>
													}
													
													@Override
													public String getKey() {
<span class="fc" id="L1389">														return id;</span>
													}
												});
									}
								}
<span class="fc" id="L1394">						: new AggregatingIterator() {</span>
									@Override
									public Row merge(Row r1, CloseableKeyIterator it1, Row r2, CloseableKeyIterator it2) throws Exception {
										try {
											// Should throw an exception with a nice message
<span class="nc" id="L1399">											return super.merge(r1, it1, r2, it2);</span>
<span class="fc" id="L1400">										} catch (Exception x) {</span>
											// Asking for an PersistingElementOverFederatedTableWithMerge implementation
<span class="fc" id="L1402">											throw new DatabaseNotReachedException(</span>
<span class="fc" id="L1403">													&quot;Inconsistency detected on row &quot; + r1.getKey()</span>
<span class="fc" id="L1404">													+ &quot; ; make &quot; + clazz.getName()</span>
<span class="fc" id="L1405">													+ &quot; implement &quot; + PersistingElementOverFederatedTableWithMerge.class.getName()</span>
<span class="fc" id="L1406">													+ &quot; to repair it&quot;, x);</span>
										}
									}
									
								};
<span class="fc" id="L1411">					ret.addIterator(lhs);</span>
<span class="fc" id="L1412">					lhs = ret;</span>
				}
<span class="fc" id="L1414">				((AggregatingIterator) lhs).addIterator(rhs);</span>
<span class="fc" id="L1415">				return lhs;</span>
			}
<span class="nc" id="L1417">		}.globalRun(table, store, c);</span>
	}

	// When creating an element from a row using a search, let's immediately set
	// its table
	after(RowWithTable row) returning (PersistingElementOverFederatedTable self) : 
		execution(PersistingElement createElementFromRow(Class, Map&lt;String, Field&gt;, Row)) 
		&amp;&amp; args(.., row){
<span class="pc bpc" id="L1425" title="1 of 2 branches missed.">		if (self != null) {</span>
<span class="fc" id="L1426">			self.setTablePostfix(row.getTablePostfix(), ((PersistingElement)self).getStore());</span>
		}
<span class="fc" id="L1428">	}</span>

	// Remote process
	void around(final MetaInformation meta, final String table,
			final Constraint c, final Set&lt;String&gt; families,
			final Class&lt;? extends PersistingElement&gt; element,
			final Process&lt;? extends PersistingElement&gt; action,
			final Callback callback, final ActionnableStore store):
		call(void ActionnableStore.process(MetaInformation, String, Constraint, Set&lt;String&gt;, Class, Process, Callback))
		&amp;&amp; inNOrm()
		&amp;&amp; target(store)
		&amp;&amp; args(meta, table, c, families, element, action, callback) {
<span class="nc bnc" id="L1440" title="All 2 branches missed.">		Class&lt;? extends PersistingElement&gt; clazz = meta == null ? null : meta</span>
<span class="nc" id="L1441">				.getClazzNoCheck();</span>
<span class="nc bnc" id="L1442" title="All 2 branches missed.">		if (!isFederated(clazz)) {</span>
<span class="nc" id="L1443">			proceed(meta, table, c, families, element, action, callback, store);</span>
<span class="nc" id="L1444">			return;</span>
		}

<span class="pc" id="L1447">		new GlobalAction&lt;Void&gt;() {</span>

			@SuppressWarnings(&quot;unchecked&quot;)
			@Override
			protected Void localRun(String mainTable, String postfix) {
<span class="fc" id="L1452">				store.process(new MetaInformation(meta).withPostfixedTable(</span>
<span class="fc" id="L1453">						mainTable, postfix), mainTable + postfix, c, families,</span>
<span class="fc" id="L1454">						element, (Process&lt;PersistingElement&gt;) action, callback);</span>
<span class="fc" id="L1455">				return null;</span>
			}
			
			@Override
			protected Void emptyValue() {
<span class="nc" id="L1460">				return null;</span>
			}

			@Override
			protected Void add(Void lhs, Void rhs) {
<span class="nc" id="L1465">				return null;</span>
			}
<span class="nc" id="L1467">		}.globalRun(table, store, c);</span>
<span class="nc" id="L1468">	}</span>

	// We're using Constraint to transmit searched table
	public static class ConstraintWithPostfix extends Constraint {
		private final String postfix;
		private final Constraint constraint;

		public ConstraintWithPostfix(Constraint c, String postfix) {
<span class="fc bfc" id="L1476" title="All 4 branches covered.">			super(c == null ? null : c.getStartKey(), c == null ? null : c</span>
<span class="fc" id="L1477">					.getEndKey());</span>
<span class="fc" id="L1478">			this.constraint = c;</span>
<span class="fc" id="L1479">			this.postfix = postfix;</span>
<span class="fc" id="L1480">		}</span>

		public String getPostfix() {
<span class="fc" id="L1483">			return this.postfix;</span>
		}

		public Constraint getConstraint() {
<span class="nc" id="L1487">			return this.constraint;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>