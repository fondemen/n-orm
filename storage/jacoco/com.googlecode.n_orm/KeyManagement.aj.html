<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>KeyManagement.aj</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">n-orm core</a> &gt; <a href="index.html" class="el_package">com.googlecode.n_orm</a> &gt; <span class="el_source">KeyManagement.aj</span></div><h1>KeyManagement.aj</h1><pre class="source lang-java linenums"><span class="pc bpc" id="L1" title="3 of 4 branches missed.">package com.googlecode.n_orm;</span>

import java.lang.reflect.Array;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import com.googlecode.n_orm.Key;
import com.googlecode.n_orm.KeyManagement;
import com.googlecode.n_orm.Persisting;
import com.googlecode.n_orm.PersistingElement;
import com.googlecode.n_orm.PropertyManagement;
import com.googlecode.n_orm.cache.perthread.Cache;
import com.googlecode.n_orm.conversion.ConversionTools;
import com.googlecode.n_orm.conversion.UnreversibleTypeException;


/**
 * To be identifiable, a persisting object must define fields to setup the key by annotating them with {@link Key}.
 * Keys must declare an order from 1 to N, must not overlap, and must be all there, e.g. if N=3, the class must declare keys for orders 1, 2 and 3.
 * Keys are inherited.
 * For non-persisting elements (i.e. elements that are not annotated with {@link Persisting}, all fields must be keys.
 * As such, an element may be identified by a string, whose format is the following:
 * &lt;code&gt;
 * id ::=   sid //for a simple element such as a character string, an integer, an enum...&lt;br&gt;
 *        | id ( {@link KeyManagement#KEY_SEPARATOR} id)* ({@link KeyManagement#KEY_END_SEPARATOR} sid)? '}' //for an element as decribed above ; each included id representing its key values, and the last optional sid representing its class&lt;br&gt;
 *        | id ( {@link KeyManagement#ARRAY_SEPARATOR}  id)* //for an array&lt;br&gt;
 * sid ::= (~({@link KeyManagement#KEY_SEPARATOR}|{@link KeyManagement#KEY_END_SEPARATOR}|{@link KeyManagement#ARRAY_SEPARATOR}))*
 * &lt;/code&gt;
 * @author fondemen
 *
 */
<span class="pc" id="L39">public aspect KeyManagement {</span>
	public static final String KEY_SEPARATOR = &quot;\u0017&quot;;  //Shouldn't be a printable char
	public static final String KEY_END_SEPARATOR = &quot;\u0001&quot;; //As small as possible so that {v=&quot;AA&quot;}.identifier (= &quot;AA&quot;+KEY_END_SEPARATOR) &lt; {v=&quot;AAA&quot;}.identifier (= &quot;AAA&quot;+KEY_END_SEPARATOR)
	public static final String ARRAY_SEPARATOR = &quot;\uFFFF&quot;; //As large as possible so that [0, 1] (identified by 0 + StringSeparator + 1) &lt; [0, 1] (identified by 0 + StringSeparator + 1 + StringSeparator + 2)
	private static KeyManagement INSTANCE;
	
	public static KeyManagement getInstance() {
<span class="fc bfc" id="L46" title="All 2 branches covered.">		if (INSTANCE == null)</span>
<span class="fc" id="L47">			INSTANCE = aspectOf();</span>
<span class="fc" id="L48">		return INSTANCE;</span>
	}

	declare error: set(@Key double PersistingElement+.*) : &quot;Floating values not supported in keys...&quot;;
	declare error: set(@Key java.lang.Double PersistingElement+.*) : &quot;Floating values not supported in keys...&quot;;
	declare error: set(@Key float PersistingElement+.*) : &quot;Floating values not supported in keys...&quot;;
	declare error: set(@Key java.lang.Float PersistingElement+.*) : &quot;Floating values not supported in keys...&quot;;
	//declare error: PersistingElement+ &amp;&amp; hasField(@Key double *) : &quot;Floating values not supported in keys...&quot;; //AJ 1.6.9 style
	declare error: set(@Key final * *.*) : &quot;A key should not be final&quot;;
	
	declare error: set(@Key(reverted=true) (!java.util.Date &amp;&amp; !boolean &amp;&amp; !Boolean &amp;&amp; !byte &amp;&amp; !Byte &amp;&amp; !short &amp;&amp; !Short &amp;&amp;!int &amp;&amp; !Integer &amp;&amp; !long &amp;&amp; !Long) *.*) : &quot;Can only revert boolean, natural or java.util.Date keys&quot;;
	
	//declare @field: * *.* : @java.lang.SuppressWarnings(value={&quot;unused&quot;}) ;
	
<span class="fc" id="L62">	private static class DecomposableString {</span>
		private static final String keySeparator;
		private static final String arraySeparator;
		private static final String keyEndSeparator;
		private static final String[] specialChars;
		
		static {
<span class="fc" id="L69">			keySeparator = KEY_SEPARATOR;</span>
<span class="fc" id="L70">			arraySeparator = ARRAY_SEPARATOR;</span>
<span class="fc" id="L71">			keyEndSeparator = KEY_END_SEPARATOR;</span>
			
<span class="fc" id="L73">			specialChars = new String [3];</span>
<span class="fc" id="L74">			specialChars[0] = keySeparator;</span>
<span class="fc" id="L75">			specialChars[1] = arraySeparator;</span>
<span class="fc" id="L76">			specialChars[2] = keyEndSeparator;</span>
		}
		
<span class="fc" id="L79">		private final KeyManagement km = KeyManagement.getInstance();</span>
		private final String ident;
		private String rest;
		
<span class="fc" id="L83">		public DecomposableString(String ident) {</span>
<span class="fc" id="L84">			this.ident = ident;</span>
<span class="fc" id="L85">			this.rest = ident;</span>
<span class="fc" id="L86">		}</span>
		
		public boolean isEmpty() {
<span class="fc" id="L89">			return this.rest.isEmpty();</span>
		}
		
		public &lt;U&gt; U detect(Class&lt;U&gt; type) {
<span class="fc" id="L93">			U ret = this.detectLast(type, false);</span>
<span class="pc bpc" id="L94" title="1 of 2 branches missed.">			if (! this.isEmpty()) {</span>
<span class="nc" id="L95">				throw new IllegalArgumentException(&quot;Could not analyze the complete string: &quot; + this.rest + &quot; left over while analyzing &quot; + this.ident + &quot; as a &quot; + type + &quot; instance.&quot;);</span>
			}
<span class="fc" id="L97">			return ret;</span>
		}
		
		protected &lt;U&gt; U detectLast(Class&lt;U&gt; expected, boolean revert) {
<span class="fc bfc" id="L101" title="All 2 branches covered.">			if (expected.isArray()) {</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">				if  (revert) throw new IllegalArgumentException(&quot;Cannot revert an array such as &quot; + expected.getName());</span>
<span class="fc" id="L103">				return detectLastArray(expected);</span>
			} else {
<span class="fc bfc" id="L105" title="All 2 branches covered.">				if (km.detectKeys(expected).size() &gt; 0) {</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">					if (revert) throw new IllegalArgumentException(&quot;Cannot revert a keyed element such as &quot; + expected.getName());</span>
<span class="fc" id="L107">					return detectLastKeyedElement(expected);</span>
				} else {
<span class="fc" id="L109">					return detectLastSimpleElement(expected, revert);</span>
				}
			}
		}
		
		private &lt;U&gt; U detectLastArray(Class&lt;U&gt; expected) {
<span class="fc" id="L115">			Class&lt;?&gt; componentType = expected.getComponentType();</span>
<span class="fc" id="L116">			LinkedList&lt;Object&gt; elements = new LinkedList&lt;Object&gt;();</span>
<span class="fc" id="L117">			String restSav = this.rest;</span>
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">			do {</span>
				try {
<span class="fc" id="L120">					elements.addFirst(this.detectLast(componentType, false));</span>
<span class="fc" id="L121">					restSav = this.rest;</span>
<span class="fc" id="L122">				} catch (Exception x) {</span>
<span class="fc" id="L123">					this.rest = restSav;</span>
<span class="fc" id="L124">					break;</span>
				}
<span class="fc bfc" id="L126" title="All 2 branches covered.">			} while (this.detectLast(arraySeparator) &amp;&amp; !this.rest.isEmpty());</span>
			
<span class="fc" id="L128">			Object[] res = elements.toArray();</span>
			@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L130">			U ret = (U) Array.newInstance(componentType, res.length);</span>
<span class="fc" id="L131">			System.arraycopy(res, 0, ret, 0, res.length);</span>
<span class="fc" id="L132">			return ret;</span>
		}
		
		@SuppressWarnings(&quot;unchecked&quot;)
		private &lt;U&gt; U detectLastKeyedElement(Class&lt;U&gt; expected) {
<span class="fc" id="L137">			Class&lt;? extends U&gt; actualType = expected;</span>
<span class="fc" id="L138">			String actualTypeName = this.detectLastUpTo(false, keyEndSeparator);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">			if (!actualTypeName.isEmpty()) {</span>
				try {
<span class="fc" id="L141">					Class&lt;?&gt; detectedCls = Class.forName(actualTypeName);</span>
<span class="fc" id="L142">					actualType = (Class&lt;? extends U&gt;) detectedCls;</span>
<span class="nc" id="L143">				} catch (ClassNotFoundException e) {</span>
<span class="nc" id="L144">					throw new IllegalArgumentException(&quot;Cannot find class &quot; + actualTypeName + &quot; as declared in key &quot; + this.ident + &quot; after &quot; + this.rest, e);</span>
<span class="nc" id="L145">				} catch (ClassCastException e) {</span>
<span class="nc" id="L146">					throw new IllegalArgumentException(&quot;Expecting a &quot; + actualTypeName + &quot; element while identifier declares incompatible type &quot; + actualTypeName + &quot; (identifier is &quot; + this.ident + ')', e);</span>
				}
			}
			
<span class="fc" id="L150">			String ident = this.rest;</span>
<span class="fc" id="L151">			this.detectLast(keyEndSeparator);</span>
<span class="fc" id="L152">			List&lt;Field&gt; keys = km.detectKeys(actualType);</span>
<span class="fc" id="L153">			Object [] vals = new Object[keys.size()];</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">			for (int i = vals.length-1; i &gt;= 0; i--) {</span>
				try {
<span class="fc" id="L156">					vals[i] = this.detectLast(keys.get(i).getType(), keys.get(i).getAnnotation(Key.class).reverted());</span>
<span class="nc" id="L157">				} catch (UnreversibleTypeException x) {</span>
<span class="nc" id="L158">					throw new UnreversibleTypeException(&quot;Key &quot; + keys.get(i) + &quot; cannot be reverted&quot;, x.getType(), x);</span>
				}
<span class="fc bfc" id="L160" title="All 2 branches covered.">				if (i &gt; 0)</span>
<span class="fc" id="L161">					this.checkLast(keySeparator);</span>
			}
<span class="fc" id="L163">			ident = ident.substring(this.rest.length());</span>
<span class="fc" id="L164">			U ret = null;</span>
			try {
<span class="fc" id="L166">				ret = (U) km.getKnownPersistingElement(ident, (Class&lt;? extends PersistingElement&gt;) actualType);</span>
<span class="nc" id="L167">			} catch (Exception x) {}</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">			if (ret == null) {</span>
<span class="fc" id="L169">				ret = km.createElement(actualType, vals);</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">				if (ret instanceof PersistingElement) {</span>
<span class="fc" id="L171">					((PersistingElement)ret).identifier = ident;</span>
<span class="fc" id="L172">					((PersistingElement)ret).getFullIdentifier();</span>
<span class="fc" id="L173">					km.register((PersistingElement) ret);</span>
				}
			}
<span class="fc" id="L176">			return ret;</span>
		}
		
		private &lt;U&gt; U detectLastSimpleElement(Class&lt;U&gt; expected, boolean revert) {
<span class="fc bfc" id="L180" title="All 2 branches covered.">			if (rest.endsWith(keyEndSeparator))</span>
<span class="fc" id="L181">				throw new IllegalArgumentException(&quot;Detecting complex type at the end of &quot; + this.rest + &quot; while expecting element of simple type &quot; + expected);</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">			return revert ?</span>
<span class="fc" id="L183">					ConversionTools.convertFromStringReverted(expected, this.detectLastSimpleId())</span>
<span class="fc" id="L184">					: ConversionTools.convertFromString(expected, this.detectLastSimpleId());</span>
		}
		
		protected String detectLastSimpleId() {
<span class="fc" id="L188">			return this.detectLastUpTo(false, specialChars);</span>
		}
		
		protected void checkLast(String expected) {
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">			if (! this.detectLast(expected))</span>
<span class="nc" id="L193">				throw new IllegalArgumentException(&quot;Expecting &quot; + expected + &quot; at the end of &quot; + this.rest + &quot; in identifier &quot; + this.ident);</span>
<span class="fc" id="L194">		}</span>
		
		protected boolean detectLast(String expected) {
<span class="fc bfc" id="L197" title="All 2 branches covered.">			if (expected.isEmpty())</span>
<span class="fc" id="L198">				return true;</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">			if (! this.rest.endsWith(expected))</span>
<span class="fc" id="L200">				return false;;</span>
<span class="fc" id="L201">			this.rest = this.rest.substring(0, this.rest.length() - expected.length());</span>
<span class="fc" id="L202">			return true;</span>
		}
		
		protected String detectLastUpTo(boolean andIncluding, String... separators) {
<span class="fc" id="L206">			String ret = this.rest;</span>
<span class="fc" id="L207">			String separator = null;</span>
<span class="fc bfc" id="L208" title="All 2 branches covered.">			for (String sc : separators) {</span>
<span class="fc" id="L209">				int sep = ret.lastIndexOf(sc);</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">				if (sep &gt;= 0) {</span>
<span class="fc" id="L211">					ret = ret.substring(sep + sc.length());</span>
<span class="fc" id="L212">					separator = sc;</span>
				}
			}
<span class="fc" id="L215">			this.checkLast(ret);</span>
<span class="pc bpc" id="L216" title="3 of 4 branches missed.">			if (andIncluding &amp;&amp; separator != null)</span>
<span class="nc" id="L217">				this.checkLast(separator);</span>
<span class="fc" id="L218">			return ret;</span>
		}
	}
	
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">	private Map&lt;Class&lt;?&gt;, List&lt;Field&gt;&gt; typeKeys = new HashMap&lt;Class&lt;?&gt;, List&lt;Field&gt;&gt;();</span>

	private transient String PersistingElement.identifier;
	private transient String PersistingElement.fullIdentifier;
	
	public void register(PersistingElement element) {
<span class="fc" id="L228">		Cache.getCache().register(element);</span>
<span class="fc" id="L229">	}</span>
	
	public void unregister(PersistingElement element) {
<span class="fc" id="L232">		Cache.getCache().unregister(element);</span>
<span class="fc" id="L233">	}</span>
	
	public void unregister(Class&lt;? extends PersistingElement&gt; clazz, String id) {
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">		if (! id.endsWith(clazz.getName())) {</span>
<span class="fc" id="L237">			id = id + clazz.getName();</span>
		}
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">		if (! id.endsWith(&quot;&quot; + KEY_END_SEPARATOR + clazz.getName())) {</span>
<span class="nc" id="L240">			throw new IllegalArgumentException(id + &quot; is not a valid identifier&quot;);</span>
		}
<span class="fc" id="L242">		Cache.getCache().unregister(id);</span>
<span class="fc" id="L243">	}</span>
	
	public PersistingElement getKnownPersistingElement(String fullIdentifier) {
<span class="fc" id="L246">		return Cache.getCache().getKnownPersistingElement(fullIdentifier);</span>
	}
	
	public PersistingElement getKnownPersistingElement(String identifier, Class&lt;? extends PersistingElement&gt; clazz) {
<span class="fc" id="L250">		return this.getKnownPersistingElement(identifier + clazz.getName());</span>
	}
	
	//For test purpose
	public void cleanupKnownPersistingElements() {
<span class="fc" id="L255">		Cache.getCache().reset();</span>
<span class="fc" id="L256">	}</span>
	
	after(PersistingElement self) returning: execution(void PersistingElement+.delete()) &amp;&amp; this(self) {
<span class="fc" id="L259">		this.unregister(self);</span>
<span class="fc" id="L260">	}</span>
	
	/**
	 * Creates an element of the expected type with the given id.
	 * Id may be a simple id or a full id (including reference to the actual type).
	 * Elements are cached using a per-thread cache (see {@link Cache}).
	 */
	public &lt;T&gt; T createElement(Class&lt;T&gt; expectedType, String id) {
		try {
<span class="fc" id="L269">			return new DecomposableString(id).detect(expectedType);</span>
<span class="nc" id="L270">		} catch (Exception x) {</span>
<span class="nc" id="L271">			throw new IllegalArgumentException(&quot;Cannot create instance of &quot; + expectedType + &quot; with id &quot; + id + &quot;: &quot; + x.getMessage(), x);</span>
		}
	}
	
	&lt;T&gt; T createElement(Class&lt;T&gt; type, Object [] keyValues) {
		
<span class="pc bpc" id="L277" title="1 of 2 branches missed.">		if(!canCreateFromKeys(type))</span>
<span class="nc" id="L278">			throw new IllegalArgumentException(&quot;Non-persisting &quot; + type + &quot; should have either no or only properties annotated with &quot; + Key.class);</span>
		
		try {
<span class="fc" id="L281">			List&lt;Field&gt; tkeys = typeKeys.get(type);</span>
<span class="pc bpc" id="L282" title="1 of 2 branches missed.">			if (tkeys == null) {</span>
<span class="nc" id="L283">				this.detectKeys(type);</span>
<span class="nc" id="L284">				tkeys = typeKeys.get(type);</span>
			}
<span class="fc" id="L286">			Class&lt;?&gt;[] tkeyTypes = new Class&lt;?&gt;[tkeys.size()];</span>
<span class="fc" id="L287">			int i = 0;</span>
<span class="fc bfc" id="L288" title="All 2 branches covered.">			for (Field key : tkeys) {</span>
<span class="fc" id="L289">				tkeyTypes[i] = key.getType();</span>
<span class="fc" id="L290">				i++;</span>
			}
			
			T ret;
			try { //using the default constructor
<span class="fc" id="L295">				ret = type.getConstructor().newInstance();</span>
<span class="fc" id="L296">				i = 0;</span>
<span class="fc" id="L297">				PropertyManagement pm = PropertyManagement.getInstance();</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">				for (Field key : tkeys) {</span>
<span class="fc" id="L299">					pm.setValue(ret, key, keyValues[i]);</span>
<span class="fc" id="L300">					i++;</span>
				}
<span class="fc" id="L302">			} catch (NoSuchMethodException x) { //Old fashion: a constructor taking keys as arguments following the order of the keys</span>
<span class="fc" id="L303">				Constructor&lt;? extends T&gt; constr = type.getConstructor(tkeyTypes);</span>
<span class="fc" id="L304">				ret = constr.newInstance(keyValues);</span>
			}
<span class="fc" id="L306">			return ret;</span>
<span class="nc" id="L307">		} catch (Exception x) {</span>
<span class="nc" id="L308">			String[] strVals = new String[keyValues.length];</span>
<span class="nc bnc" id="L309" title="All 2 branches missed.">			for (int i = 0; i &lt; strVals.length; i++) {</span>
<span class="nc" id="L310">				strVals[i] = ConversionTools.convertToString(keyValues[i]);</span>
			}
<span class="nc" id="L312">			throw new RuntimeException(&quot;Cannot build new instance of &quot; + type + &quot; with key values &quot; + Arrays.toString(strVals), x);</span>
		}
	}

	public boolean canCreateFromKeys(Class&lt;?&gt; type) {
<span class="fc bfc" id="L317" title="All 2 branches covered.">		if (!PersistingElement.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L318">			PropertyManagement pm = PropertyManagement.getInstance();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">			for (Field property : pm.getProperties(type)) {</span>
<span class="pc bpc" id="L320" title="1 of 4 branches missed.">				if (pm.isProperty(property) &amp;&amp; ! this.isKey(property))</span>
<span class="fc" id="L321">					return false;</span>
			}
		}
<span class="fc" id="L324">		return true;</span>
	}
	
	public List&lt;Field&gt; PersistingElement.getKeys() {
<span class="fc" id="L328">		return new ArrayList&lt;Field&gt;(KeyManagement.getInstance().typeKeys.get(this.getClass()));</span>
	}

	public List&lt;Field&gt; detectKeys(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L332" title="All 2 branches covered.">		if (! typeKeys.containsKey(clazz)) {</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">			if (PropertyManagement.getInstance().isSimplePropertyType(clazz))</span>
<span class="fc" id="L334">				return new ArrayList&lt;Field&gt;(0);</span>
<span class="fc" id="L335">			ArrayList&lt;Field&gt; foundKeys = new ArrayList&lt;Field&gt;();</span>
<span class="fc" id="L336">			int maxKeyOrder = -1;</span>
<span class="fc" id="L337">			boolean isPersisting = PersistingElement.class.isAssignableFrom(clazz);</span>
			
<span class="fc bfc" id="L339" title="All 2 branches covered.">			for (Field f : PropertyManagement.getInstance().getProperties(clazz)) {</span>
<span class="fc bfc" id="L340" title="All 2 branches covered.">				if (f.isAnnotationPresent(Key.class)) {</span>
<span class="fc" id="L341">					this.checkKey(f);</span>
					
<span class="fc" id="L343">					Key keyDescriptor = f.getAnnotation(Key.class);</span>
<span class="fc" id="L344">					int order = keyDescriptor.order()-1;</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">					while (foundKeys.size() &lt;= order) foundKeys.add(null);</span>
<span class="fc" id="L346">					Field old = foundKeys.set(order, f);</span>
<span class="fc bfc" id="L347" title="All 2 branches covered.">					if (old != null)</span>
<span class="fc" id="L348">						throw new IllegalArgumentException(&quot;Class &quot; + clazz + &quot; has keys with same order &quot; + f + &quot; and &quot; + old);</span>
<span class="fc" id="L349">					maxKeyOrder = Math.max(maxKeyOrder, order);</span>
				} else {
<span class="pc bpc" id="L351" title="1 of 2 branches missed.">					if (isPersisting)</span>
<span class="fc" id="L352">						PropertyManagement.getInstance().checkProperty(f);</span>
					else
<span class="nc" id="L354">						throw new IllegalStateException(&quot;The non persisting &quot; + clazz + &quot; should have either only or no property annotated with &quot; + Key.class + &quot; unlike property &quot; + f );</span>
				}
			}
			
<span class="fc bfc" id="L358" title="All 2 branches covered.">			if (maxKeyOrder &lt; 0)</span>
<span class="fc" id="L359">				throw new IllegalStateException(&quot;A persisting class should declare at least a field annotated with &quot; + Key.class + &quot; unlike &quot; + clazz);</span>
			
<span class="fc bfc" id="L361" title="All 2 branches covered.">			for (int i = 1; i &lt; maxKeyOrder; i++) {</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">				if (foundKeys.get(i) == null)</span>
<span class="fc" id="L363">					throw new IllegalArgumentException(&quot;Class &quot; + clazz + &quot; misses key of index &quot; + i + &quot; ; check that your key are all public.&quot;);</span>
			}
			
<span class="fc" id="L366">			foundKeys.trimToSize();</span>
			
<span class="fc" id="L368">			typeKeys.put(clazz, foundKeys);</span>
		}
<span class="fc" id="L370">		return typeKeys.get(clazz);</span>
	}
	
	public void checkKey(Field f) {
<span class="fc" id="L374">		PropertyManagement.getInstance().checkProperty(f);</span>
		
<span class="fc bfc" id="L376" title="All 2 branches covered.">		if (f.getAnnotation(Key.class).order() &lt;= 0)</span>
<span class="fc" id="L377">			throw new IllegalArgumentException(&quot;A key should declare an order which must bhe at least 1.&quot;);</span>
		
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">		if ((f.getModifiers()&amp;Modifier.FINAL) != 0)</span>
<span class="nc" id="L380">			throw new IllegalStateException(&quot;The key &quot; + f + &quot; should not be final.&quot;);</span>
<span class="fc" id="L381">	}</span>
	
	public boolean isKey(Field key) {
		try {
<span class="fc" id="L385">			this.checkKey(key);</span>
<span class="fc" id="L386">			return true;</span>
<span class="fc" id="L387">		} catch (Exception x) {</span>
<span class="fc" id="L388">			return false;</span>
		}
	}
	
	public String createIdentifier(Object element, Class&lt;?&gt; expected) {
<span class="fc" id="L393">		return this.createIdentifier(element, expected, true);</span>
	}
	
	public String createIdentifier(Object element, Class&lt;?&gt; expected, boolean canCheckCache) {
<span class="pc bpc" id="L397" title="1 of 4 branches missed.">		if (expected != null &amp;&amp; ! expected.isInstance(element))</span>
<span class="nc" id="L398">			throw new ClassCastException(&quot;Element &quot; + element + &quot; of class &quot; + element.getClass() + &quot; is not compatible with &quot; + expected);</span>
		try {
<span class="fc" id="L400">			StringBuffer ret = new StringBuffer();</span>
			
<span class="fc bfc" id="L402" title="All 6 branches covered.">			if (canCheckCache &amp;&amp; (element instanceof PersistingElement) &amp;&amp; ((PersistingElement)element).identifier != null) {</span>
<span class="fc" id="L403">				ret.append(((PersistingElement)element).identifier);</span>
			} else {
<span class="fc" id="L405">				boolean fst = true;</span>
<span class="fc" id="L406">				PropertyManagement pm = PropertyManagement.getInstance();</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">				for (Field key : this.detectKeys(element.getClass())) {</span>
<span class="fc bfc" id="L408" title="All 2 branches covered.">					if (fst) fst = false; else ret.append(KEY_SEPARATOR);</span>
<span class="fc" id="L409">					Object o = pm.readValue(element, key);</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">					if (o == null)</span>
<span class="fc" id="L411">						throw new IllegalStateException(&quot;A key cannot be null as it is the case for key &quot; + key + &quot; of &quot; + element);</span>
//					if (key.getType().isArray() &amp;&amp; Array.getLength(o) == 0)
//						throw new IllegalStateException(&quot;An array key cannot be empty as it is the case for key &quot; + key + &quot; of &quot; + element);
<span class="fc bfc" id="L414" title="All 2 branches covered.">					if (key.getAnnotation(Key.class).reverted())</span>
<span class="fc" id="L415">						ret.append(ConversionTools.convertToStringReverted(o, key.getType()));</span>
					else
<span class="fc" id="L417">						ret.append(ConversionTools.convertToString(o, key.getType()));</span>
				}
<span class="fc" id="L419">				ret.append(KEY_END_SEPARATOR);</span>
			}
			
<span class="fc bfc" id="L422" title="All 4 branches covered.">			if (expected != null &amp;&amp; !element.getClass().equals(expected)) {</span>
<span class="fc" id="L423">				ret.append(element.getClass().getName());</span>
			}
			
<span class="fc" id="L426">			return ret.toString();</span>
<span class="fc" id="L427">		} catch (RuntimeException x) {</span>
<span class="fc" id="L428">			throw x;</span>
<span class="nc" id="L429">		} catch (Exception x) {</span>
<span class="nc" id="L430">			throw new RuntimeException(x);</span>
		}
	}
	
	private volatile transient boolean PersistingElement.creatingIdentifier = false;
	
	/**
	 * Checks whether this persisting element has a stable key.
	 * This means that each one of its keys is set to a valid and unchanged value.
	 */
	public void PersistingElement.checkIsValid() throws IllegalStateException {
<span class="pc bpc" id="L441" title="1 of 2 branches missed.">		if (this.getIdentifier() == null)</span>
<span class="nc" id="L442">			throw new IllegalStateException(&quot;Persisting element ot type &quot; + this.getClass() + &quot; is missing some of its key values.&quot;);</span>
<span class="fc" id="L443">		KeyManagement km = KeyManagement.getInstance();</span>
<span class="fc" id="L444">		String newKey = km.createIdentifier(this, getClass(), false);</span>
<span class="fc bfc" id="L445" title="All 2 branches covered.">		if (!this.getIdentifier().equals(newKey)) {</span>
<span class="fc" id="L446">			km.unregister(this);</span>
<span class="pc bpc" id="L447" title="1 of 2 branches missed.">			if (newKey == null)</span>
<span class="nc" id="L448">				throw new IllegalStateException(&quot;One of the key value for &quot; + this + &quot; is no longer valid.&quot;);</span>
			else
<span class="fc" id="L450">				throw new IllegalStateException(&quot;At least a key for object &quot; + this + &quot; has changed (identifier would be now &quot; + newKey + &quot;)&quot;);</span>
		}
<span class="fc" id="L452">		km.register(this);</span>
<span class="fc" id="L453">	}</span>

	public String PersistingElement.getIdentifier() {
<span class="fc bfc" id="L456" title="All 4 branches covered.">		if (this.identifier == null &amp;&amp; !this.creatingIdentifier) {</span>
<span class="fc" id="L457">			this.creatingIdentifier = true;</span>
			try {
<span class="fc" id="L459">				this.identifier = KeyManagement.getInstance().createIdentifier(this, this.getClass());</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">				if (this.identifier == null)</span>
<span class="nc" id="L461">					throw new IllegalStateException(&quot;Element &quot; + this + &quot; has no identifier ; have all keys been set ?&quot;);</span>
<span class="fc" id="L462">				this.getFullIdentifier(); //Must be created as soon as this function is valid</span>
<span class="fc" id="L463">			} finally {</span>
<span class="fc" id="L464">				this.creatingIdentifier = false;</span>
<span class="fc" id="L465">			}</span>
		}
<span class="fc" id="L467">		return this.identifier;</span>
	}

	public String PersistingElement.getFullIdentifier() {
<span class="fc bfc" id="L471" title="All 2 branches covered.">		if (this.fullIdentifier == null) {</span>
<span class="fc" id="L472">			this.fullIdentifier = KeyManagement.getInstance().createIdentifier(this, PersistingElement.class);</span>
<span class="pc bpc" id="L473" title="1 of 2 branches missed.">			if (this.fullIdentifier == null)</span>
<span class="nc" id="L474">				throw new IllegalStateException(&quot;Element &quot; + this + &quot; has no identifier ; have all keys been set ?&quot;);</span>
<span class="fc" id="L475">			this.getIdentifier(); //Must be created as soon as this function is valid</span>
		}
<span class="fc" id="L477">		return this.fullIdentifier;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>