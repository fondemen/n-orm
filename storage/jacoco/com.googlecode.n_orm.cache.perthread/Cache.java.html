<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Cache.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="right"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">n-orm core</a> &gt; <a href="index.html" class="el_package">com.googlecode.n_orm.cache.perthread</a> &gt; <span class="el_source">Cache.java</span></div><h1>Cache.java</h1><pre class="source lang-java linenums"><span class="nc" id="L1">package com.googlecode.n_orm.cache.perthread;</span>

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.googlecode.n_orm.PersistingElement;
import com.googlecode.n_orm.PersistingMixin;

/**
 * A cache for temporarily storing {@link PersistingElement}s.&lt;br&gt;
 * There is a cache per thread, so that cached elements are thread safe unless explicitly shared across threads.
 * Only thread owning a cache is allowed to use this cache.&lt;br&gt;
 * To get a cache, use {@link #getCache()} within the using thread.&lt;br&gt;
 * Caches are limited in size (see {@link #getMaxElementsInCache()}).
 * Cached elements are removed as soon as they have not been accessed since a certain amount of time (see {@link #getTimeToLiveSeconds()}).&lt;br&gt;
 * Caches for dead thread are recycled, but in case they have not been used during a certain amount of time (see {@link #getTimeToLiveSeconds()}), they are dropped.
 * @author fondemen
 *
 */
<span class="pc bpc" id="L25" title="1 of 2 branches missed.">public class Cache {</span>
	
<span class="pc bpc" id="L27" title="1 of 2 branches missed.">	private static class CleanerThread extends Thread {</span>

		@Override
		public void run() {
<span class="nc" id="L31">			while (true) {</span>
				try {
<span class="fc" id="L33">					Thread.sleep(periodBetweenCacheCleanupMS);</span>
<span class="fc" id="L34">					this.step();</span>
<span class="nc" id="L35">				} catch (Throwable e) {</span>
<span class="nc" id="L36">					logger.log(Level.WARNING, &quot;Problem while waiting next cache cleanup.&quot;, e);</span>
				}
			}
		}

		public void step() {
			
			try {
<span class="fc" id="L44">				long now = System.currentTimeMillis();</span>
<span class="fc" id="L45">				LIFO&lt;Cache&gt; available = new LIFO&lt;Cache&gt;();</span>
				
				try {
					
					Thread[] threads;
<span class="pc" id="L50">					synchronized(perThreadCaches) {</span>
<span class="fc" id="L51">						Set&lt;Thread&gt; threadsSet = perThreadCaches.keySet();</span>
<span class="fc" id="L52">						threads = threadsSet.toArray(new Thread[threadsSet.size()]);</span>
					}
<span class="fc bfc" id="L54" title="All 2 branches covered.">					for(Thread t : threads) {</span>
						Cache cache;
<span class="fc bfc" id="L56" title="All 2 branches covered.">						if (!isValid(t)) {</span>
<span class="pc" id="L57">							synchronized(perThreadCaches) {</span>
<span class="fc" id="L58">								cache = perThreadCaches.remove(t);</span>
							}
<span class="pc bpc" id="L60" title="1 of 2 branches missed.">							if (cache != null) {</span>
<span class="fc" id="L61">								available.push(cache);</span>
<span class="fc" id="L62">								cache.stopped = now;</span>
							}
						} else {
<span class="fc" id="L65">							cache = perThreadCaches.get(t);</span>
<span class="pc bpc" id="L66" title="1 of 2 branches missed.">							if (cache != null) {</span>
<span class="pc bpc" id="L67" title="2 of 4 branches missed.">								if (cache.cache != null &amp;&amp; cache.stopped == -1) {</span>
<span class="fc" id="L68">									cache.shouldCleanup = true;</span>
								} else {
<span class="nc bnc" id="L70" title="All 2 branches missed.">									assert false;</span>
<span class="nc" id="L71">									synchronized(perThreadCaches) {</span>
<span class="nc" id="L72">										perThreadCaches.remove(t);</span>
									}
								}
							}
						}
					}
<span class="nc" id="L78">				} catch (RuntimeException x) {</span>
<span class="nc" id="L79">					logger.log(Level.WARNING, &quot;Problem while checking cache.&quot;, x);</span>
				}
				
<span class="pc" id="L82">				synchronized(availableCaches) {</span>
					try {
<span class="fc" id="L84">						availableCaches.pushAll(available);</span>
<span class="nc" id="L85">					} catch (RuntimeException x) {</span>
<span class="nc" id="L86">						logger.log(Level.WARNING, &quot;Problem while checking cache.&quot;, x);</span>
					}
<span class="fc" id="L88">					available.clear();</span>
				}
				
				try {
<span class="fc" id="L92">					Iterator&lt;Cache&gt; ai = availableCaches.iterator();</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">availableCachesCheck:while (ai.hasNext()) {</span>
<span class="fc" id="L94">						Cache cache = ai.next();</span>
<span class="pc bpc" id="L95" title="1 of 2 branches missed.">						if (cache == null) {</span>
<span class="nc" id="L96">							logger.warning(&quot;Invalid state: got an empty object while iterating over available caches.&quot;);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">							if (ai.hasNext()) {</span>
<span class="nc" id="L98">								cache = ai.next();</span>
<span class="nc bnc" id="L99" title="All 2 branches missed.">								if (cache == null) {</span>
									String cachesStr;
									try {
<span class="nc" id="L102">										cachesStr = availableCaches.toString();</span>
<span class="nc" id="L103">										logger.severe(&quot;Invalid state: cannot continue iterating over available caches &quot; + cachesStr);</span>
<span class="nc" id="L104">									} catch (Throwable t) {</span>
<span class="nc" id="L105">										logger.log(Level.SEVERE, &quot;It seems that available caches are lost. No mean to recover, resetting.&quot;, t);</span>
<span class="nc" id="L106">										availableCaches.clear();</span>
									}
<span class="nc" id="L108">									break availableCachesCheck;</span>
								}
							} else
								break availableCachesCheck;
						}
<span class="pc" id="L113">						synchronized(cache) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">							if ((cache.stopped+(timeToLiveSeconds*1000)) &lt; now) {</span>
<span class="fc" id="L115">								ai.remove();</span>
<span class="fc" id="L116">								cache.close();</span>
<span class="pc bpc" id="L117" title="1 of 2 branches missed.">							} else if (cache.isClosed()) {</span>
<span class="nc" id="L118">								ai.remove();</span>
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">							} else if (isValid(cache.thread)) {</span>
<span class="nc" id="L120">								ai.remove();</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">								assert perThreadCaches.get(cache.thread) == cache;</span>
							}
						}
					}
<span class="nc" id="L125">				} catch (RuntimeException x) {</span>
<span class="nc" id="L126">					logger.log(Level.WARNING, &quot;Problem while checking cache.&quot;, x);</span>
				}
<span class="nc" id="L128">			} finally {</span>
			
<span class="pc" id="L130">				synchronized(this) {</span>
<span class="pc" id="L131">					this.notifyAll();</span>
				}
<span class="nc" id="L133">			}</span>
<span class="fc" id="L134">		}</span>
	}

<span class="fc" id="L137">	private static Logger logger = Logger.getLogger(Cache.class.getName());</span>

<span class="fc" id="L139">	private static int periodBetweenCacheCleanupMS = 1000;</span>
<span class="fc" id="L140">	private static int timeToLiveSeconds = 10;</span>
<span class="fc" id="L141">	private static int maxElementsInCache = 10000;</span>

	
	private static final HashMap&lt;Thread, Cache&gt; perThreadCaches;
	private static final LIFO&lt;Cache&gt; availableCaches;
	private static final Thread cacheCleaner;
	
	static {
<span class="fc" id="L149">		perThreadCaches = new HashMap&lt;Thread, Cache&gt;();</span>
<span class="fc" id="L150">		availableCaches = new LIFO&lt;Cache&gt;();</span>
<span class="fc" id="L151">		cacheCleaner = new CleanerThread();</span>
<span class="fc" id="L152">		cacheCleaner.setDaemon(true);</span>
<span class="fc" id="L153">		cacheCleaner.start();</span>
<span class="fc" id="L154">		logger.info(&quot;Per-thread caching system started.&quot;);</span>
	}
	
	private static boolean isValid(Thread thread) {
<span class="pc bpc" id="L158" title="2 of 6 branches missed.">		return thread != null &amp;&amp; thread.isAlive() &amp;&amp; thread.getThreadGroup() != null;</span>
	}
	
	/**
	 * Time during which a element is kept in the cache (10s by default).
	 * If an element is accessed (e.g. by storing or activating it), its time to live is reseted.
	 * A cache is also kept during this time once its corresponding thread is over, so that it can be reused by another thread.
	 * @return time to live in seconds
	 */
	public static int getTimeToLiveSeconds() {
<span class="fc" id="L168">		return timeToLiveSeconds;</span>
	}

	/**
	 * Sets time during which a element is kept in the cache.
	 * If an element is accessed (e.g. by storing or activating it), its time to live is reseted.
	 * A cache is also kept during this time once its corresponding thread is over, so that it can be reused by another thread.
	 * @param timeToLiveSeconds time to live in seconds
	 */
	public static void setTimeToLiveSeconds(int timeToLiveSeconds) {
<span class="fc" id="L178">		Cache.timeToLiveSeconds = timeToLiveSeconds;</span>
<span class="fc" id="L179">	}</span>

	/**
	 * The maximum number of elements that can be kept in a (per-thread) cache (10 000 by default).
	 */
	public static int getMaxElementsInCache() {
<span class="fc" id="L185">		return maxElementsInCache;</span>
	}

	/**
	 * Sets the maximum number of elements that can be kept in a (per-thread) cache.
	 */
	public static void setMaxElementsInCache(int maxElementsInCache) {
<span class="fc" id="L192">		Cache.maxElementsInCache = maxElementsInCache;</span>
<span class="fc" id="L193">	}</span>

	/**
	 * The time between two cache cleanups (1s by default).
	 * Caches with alive thread are asked to cleanup at next access: all elements that have not been accessed since their time to live are discarded.
	 * Caches with dead threads are checked for time to live and discarded if this period is over, otherwise their elements are immediately checked for time to live.
	 * @return period between two cache cleanups in milliseconds
	 */
	public static int getPeriodBetweenCacheCleanupMS() {
<span class="fc" id="L202">		return periodBetweenCacheCleanupMS;</span>
	}

	/**
	 * The time between two cache cleanups.
	 * Caches with alive thread are asked to cleanup at next access: all elements that have not been accessed since their time to live are discarded.
	 * Caches with dead threads are checked for time to live and discarded if this period is over, otherwise their elements are immediately checked for time to live.
	 * @param periodBetweenCacheCleanupMS period between two cache cleanups in milliseconds
	 */
	public static void setPeriodBetweenCacheCleanupMS(
			int periodBetweenCacheCleanupMS) {
<span class="fc" id="L213">		Cache.periodBetweenCacheCleanupMS = periodBetweenCacheCleanupMS;</span>
<span class="fc" id="L214">	}</span>

	static void waitNextCleanup() throws InterruptedException {
<span class="pc" id="L217">		synchronized(cacheCleaner) {</span>
<span class="fc" id="L218">			cacheCleaner.wait();</span>
		}
<span class="fc" id="L220">	}</span>
	
	static boolean knowsCache(Thread thread) {
<span class="fc bfc" id="L223" title="All 2 branches covered.">		return findCache(thread)!= null;</span>
	}
	
	static void cleanRecyclableCaches() {
<span class="pc" id="L227">		synchronized(availableCaches) {</span>
<span class="fc" id="L228">			availableCaches.clear();</span>
		}
<span class="fc" id="L230">	}</span>
	
	public static Cache findCache(Thread thread) {
<span class="pc" id="L233">		synchronized(perThreadCaches) {</span>
<span class="fc" id="L234">			return perThreadCaches.get(thread);</span>
		}
	}
	
	/**
	 * Gives a cache to the current thread.
	 * In case this cache does not already exists, creates it.
	 */
	public static Cache getCache() {
<span class="fc" id="L243">		Cache res = findCache(Thread.currentThread());</span>
		
<span class="fc bfc" id="L245" title="All 2 branches covered.">		if (res == null) {</span>
<span class="fc" id="L246">			res = (Cache) availableCaches.pop(); //Most recent in the queue ; if closed, all the others in availableCaches should be closed...</span>
<span class="fc bfc" id="L247" title="All 2 branches covered.">			if (res != null) {</span>
<span class="pc" id="L248">				synchronized(res) {</span>
<span class="pc bpc" id="L249" title="1 of 2 branches missed.">					if (res.isClosed())</span>
<span class="nc" id="L250">						res = null;</span>
					else {
<span class="fc" id="L252">						res.init();</span>
<span class="fc" id="L253">						res.cleanInvalidElements();</span>
<span class="fc" id="L254">						logger.finer(&quot;Reusing existing cache for thread &quot; + res.thread);</span>
					}
				}
			}
		}
		
<span class="fc bfc" id="L260" title="All 2 branches covered.">		if (res == null) {</span>
<span class="fc" id="L261">			res = new Cache();</span>
		}
		
<span class="pc bpc" id="L264" title="2 of 4 branches missed.">		assert isValid(res.thread);</span>
<span class="pc bpc" id="L265" title="2 of 4 branches missed.">		assert !res.isClosed();</span>
<span class="pc bpc" id="L266" title="2 of 4 branches missed.">		assert !availableCaches.contains(res);</span>
<span class="pc bpc" id="L267" title="2 of 4 branches missed.">		assert perThreadCaches.get(Thread.currentThread()) == res;</span>
		
<span class="fc" id="L269">		return res;</span>
	}
	
	/**
	 * A string identifier for the thread.
	 */
	public static String getThreadId(Thread thread) {
<span class="fc" id="L276">		return Long.toHexString(thread.getId());</span>
	}
	
	private static class Element {
		private long lastAccessDate;
		private PersistingElement element;
		public Element(PersistingElement element) {
<span class="fc" id="L283">			super();</span>
<span class="fc" id="L284">			this.element = element;</span>
<span class="fc" id="L285">			this.lastAccessDate = System.currentTimeMillis();</span>
<span class="fc" id="L286">		}</span>
		
		public PersistingElement getElement() {
<span class="fc" id="L289">			this.update();</span>
<span class="fc" id="L290">			return element;</span>
		}
		
		public void setElement(PersistingElement element) {
<span class="fc" id="L294">			this.update();</span>
<span class="fc" id="L295">			this.element = element;</span>
<span class="fc" id="L296">		}</span>
		
		public void update() {
<span class="fc" id="L299">			this.lastAccessDate = System.currentTimeMillis();</span>
<span class="fc" id="L300">		}</span>
		
		public boolean isValid() {
<span class="fc bfc" id="L303" title="All 2 branches covered.">			return (this.lastAccessDate+(timeToLiveSeconds*1000)) &gt; System.currentTimeMillis();</span>
		}
	}
	
	private volatile Map&lt;String, Element&gt; cache;
	private volatile Thread thread;
	private volatile String threadId;
<span class="fc" id="L310">	private boolean active = true;</span>
	private volatile boolean shouldCleanup;
<span class="fc" id="L312">	private volatile long stopped = -1;</span>

<span class="fc" id="L314">	private Cache() {</span>
<span class="fc" id="L315">		this.init();</span>
<span class="fc" id="L316">	}</span>
	
	/**
	 * Whether this cache actually caches.
	 */
	protected boolean isActive() {
<span class="nc" id="L322">		return active;</span>
	}

	/**
	 * Making it possible to disable this cache for test purpose.
	 * Usage in production is strongly discouraged.
	 * @param active
	 */
	protected void setActive(boolean active) {
<span class="nc" id="L331">		this.active = active;</span>
<span class="nc" id="L332">	}</span>

	private synchronized void init() {
<span class="fc" id="L335">		this.thread = Thread.currentThread();</span>
<span class="fc" id="L336">		this.threadId = getThreadId(this.thread);</span>
		
<span class="pc bpc" id="L338" title="1 of 2 branches missed.">		this.cache = new HashMap&lt;String, Cache.Element&gt;();</span>
<span class="fc" id="L339">		this.stopped = -1;</span>
		
<span class="fc" id="L341">		this.active = true;</span>
		
<span class="pc" id="L343">		synchronized(perThreadCaches) {</span>
<span class="fc" id="L344">			perThreadCaches.put(this.thread, this);</span>
		}
<span class="fc" id="L346">		logger.fine(&quot;Cache started for &quot; + this.thread + &quot; with id &quot; + this.threadId);</span>
<span class="fc" id="L347">	}</span>
	
	protected void checkState() {
<span class="pc bpc" id="L350" title="2 of 4 branches missed.">		assert !this.isClosed();</span>
<span class="fc" id="L351">		Thread cur = Thread.currentThread();</span>
<span class="pc bpc" id="L352" title="1 of 2 branches missed.">		if (this.thread != cur)</span>
<span class="nc bnc" id="L353" title="All 2 branches missed.">			throw new IllegalStateException(cur.toString() + &quot; with id &quot; + cur.getId() + &quot; is not allowed to acccess cache for &quot; + (this.thread.isAlive() ? &quot;alive&quot; : &quot;dead&quot;) + &quot; &quot; + this.thread + &quot; with id &quot; + this.thread.getId());</span>
<span class="fc" id="L354">		this.cleanIfNecessary();</span>
<span class="fc" id="L355">	}</span>
	
	private void cleanIfNecessary() {
<span class="fc bfc" id="L358" title="All 2 branches covered.">		if (this.shouldCleanup)</span>
<span class="fc" id="L359">			this.cleanInvalidElements();</span>
<span class="fc" id="L360">	}</span>
	
	/**
	 * @return the element with the eldest last usage (null if cache is empty)
	 */
	private synchronized Element cleanInvalidElements() {
<span class="fc" id="L366">		this.shouldCleanup = false;</span>
<span class="fc" id="L367">		Element eldest = null;</span>
<span class="fc" id="L368">		Iterator&lt;Entry&lt;String, Element&gt;&gt; it = cache.entrySet().iterator();</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">		while (it.hasNext()) {</span>
<span class="fc" id="L370">			Element elt = it.next().getValue();</span>
<span class="fc bfc" id="L371" title="All 2 branches covered.">			if (!elt.isValid()) {</span>
<span class="fc" id="L372">				it.remove();</span>
<span class="fc bfc" id="L373" title="All 2 branches covered.">			} else if (eldest == null) {</span>
<span class="fc" id="L374">				eldest = elt;</span>
<span class="fc bfc" id="L375" title="All 2 branches covered.">			} else if (eldest.lastAccessDate &gt; elt.lastAccessDate) {</span>
<span class="fc" id="L376">				eldest = elt;</span>
			}
		}
<span class="fc" id="L379">		logger.fine(&quot;Cleaned cache for thread &quot; + this.thread + &quot; with id &quot; + threadId);</span>
<span class="fc" id="L380">		return eldest;</span>
	}
	
	/**
	 * Registers an element in the cache.&lt;br&gt;
	 * Only thread for this cache has access to this method.&lt;br&gt;
	 * In case this cache is marked for cleanup, elements are checked for their time to live (see {@link #setTimeToLiveSeconds(int)}).&lt;br&gt;
	 * In case the maximum number of cacheable elements is reached, element with the eldest access id removed from the cache (see {@link #setMaxElementsInCache(int)})
	 * @param element the element to be cached (during {@link #getTimeToLiveSeconds()})
	 * @throws IllegalStateException in case this thread is not the thread for this cache
	 */
	public void register(PersistingElement element) throws IllegalStateException {
<span class="fc" id="L392">		this.checkState();</span>
		
<span class="pc bpc" id="L394" title="1 of 2 branches missed.">		if (!this.active)</span>
<span class="nc" id="L395">			return;</span>
		
<span class="pc bpc" id="L397" title="1 of 2 branches missed.">		if (element == null)</span>
<span class="nc" id="L398">			return;</span>
<span class="fc" id="L399">		String id = element.getFullIdentifier();</span>
<span class="fc" id="L400">		Element cached = this.cache.get(id);</span>
<span class="fc bfc" id="L401" title="All 2 branches covered.">		if (cached == null) {</span>
<span class="fc" id="L402">			cached = new Element(element);</span>
<span class="fc" id="L403">			this.cache.put(id, cached);</span>
		} else {
<span class="fc" id="L405">			cached.setElement(element);</span>
		}
<span class="fc bfc" id="L407" title="All 2 branches covered.">		while (this.cache.size() &gt; maxElementsInCache) //Should happen only once</span>
<span class="fc" id="L408">			this.cache.remove(this.cleanInvalidElements().getElement().getFullIdentifier());</span>
<span class="fc" id="L409">		logger.finer(&quot;Registered element &quot; + element + &quot; for thread &quot; + this.thread + &quot; with id &quot; + threadId);</span>
<span class="fc" id="L410">	}</span>
	
	/**
	 * Removes an element in the cache.&lt;br&gt;
	 * Only thread for this cache has access to this method.&lt;br&gt;
	 * In case this cache is marked for cleanup, elements are checked for their time to live (see {@link #setTimeToLiveSeconds(int)}).&lt;br&gt;
	 * @param element the element to be uncached
	 * @throws IllegalStateException in case this thread is not the thread for this cache
	 */
	public void unregister(PersistingElement element) throws IllegalStateException {
<span class="fc" id="L420">		this.checkState();</span>
		
<span class="fc bfc" id="L422" title="All 2 branches covered.">		if (this.cache.remove(element.getFullIdentifier()) != null) {</span>
<span class="fc" id="L423">			logger.finer(&quot;Unregistered element with &quot; + element + &quot; for thread &quot; + this.thread + &quot; with id &quot; + threadId);</span>
		}
<span class="fc" id="L425">	}</span>
	
	/**
	 * Removes an element in the cache given by its full identifier.&lt;br&gt;
	 * Only thread for this cache has access to this method.&lt;br&gt;
	 * In case this cache is marked for cleanup, elements are checked for their time to live (see {@link #setTimeToLiveSeconds(int)}).&lt;br&gt;
	 * @param fullIdentifier the full id of the element to be uncached
	 * @throws IllegalStateException in case this thread is not the thread for this cache
	 */
	public void unregister(String fullIdentifier) throws IllegalStateException {
<span class="fc" id="L435">		this.checkState();</span>
		
<span class="pc bpc" id="L437" title="1 of 2 branches missed.">		if (this.cache.remove(fullIdentifier) != null) {</span>
<span class="nc" id="L438">			logger.finer(&quot;Unregistered element with &quot; + PersistingMixin.getInstance().identifierToString(fullIdentifier) + &quot; for thread &quot; + this.thread + &quot; with id &quot; + threadId);</span>
		}
<span class="fc" id="L440">	}</span>
	
	/**
	 * Finds an element in the cache according to its full identifier.&lt;br&gt;
	 * Only thread for this cache has access to this method.&lt;br&gt;
	 * In case this cache is marked for cleanup, elements are checked for their time to live (see {@link #setTimeToLiveSeconds(int)}).&lt;br&gt;
	 * @param fullIdentifier the full identifier of the element to be cached; null if not found
	 * @throws IllegalStateException in case this thread is not the thread for this cache
	 * @see PersistingElement#getFullIdentifier()
	 */
	public PersistingElement getKnownPersistingElement(String fullIdentifier) {
<span class="fc" id="L451">		this.checkState();</span>
<span class="fc" id="L452">		Element res = (Element) this.cache.get(fullIdentifier);</span>
<span class="fc bfc" id="L453" title="All 2 branches covered.">		if (res == null)</span>
<span class="fc" id="L454">			return null;</span>
		else {
<span class="fc" id="L456">			PersistingElement ret = res.getElement();</span>
<span class="fc" id="L457">			logger.finest(&quot;Found element &quot; + ret + &quot; from cache for thread &quot; + this.thread + &quot; with id &quot; + this.threadId);</span>
<span class="fc" id="L458">			return ret;</span>
		}
	}

	/**
	 * Finds an element in the cache according to its identifier.&lt;br&gt;
	 * Only thread for this cache has access to this method.&lt;br&gt;
	 * In case this cache is marked for cleanup, elements are checked for their time to live (see {@link #setTimeToLiveSeconds(int)}).&lt;br&gt;
	 * @param identifier the full identifier of the element to be cached; null if not found
	 * @param clazz the class that the element instantiates (see {@link Object#getClass()}; null if not found
	 * @throws IllegalStateException in case this thread is not the thread for this cache
	 * @see PersistingElement#getIdentifier()
	 */
	public PersistingElement getKnownPersistingElement(String identifier, Class&lt;? extends PersistingElement&gt; clazz) {
<span class="nc" id="L472">		return this.getKnownPersistingElement(identifier + clazz.getName());</span>
	}
	
	/**
	 * The size of the cache.
	 * This method checks elements for their time to live regardless the cache is marked for that or not.
	 */
	public int size() {
<span class="fc" id="L480">		this.cleanInvalidElements();</span>
<span class="fc" id="L481">		return this.cache.size();</span>
	}
	
	/**
	 * Clears the cache.
	 */
	public void reset() {
<span class="fc" id="L488">		this.cache.clear();</span>
<span class="fc" id="L489">		logger.finer(&quot;Reseted cache for thread &quot; + this.thread + &quot; with id &quot; + threadId);</span>
<span class="fc" id="L490">	}</span>
	
	/**
	 * Checks if this cache can be used or not.
	 * A cache cannot be used if its thread is dead and if its time to live is over.
	 * A closed cache must not be used in any case (necessary resources were released)
	 * @return whether this cache has bee closed
	 * @see #close()
	 */
	public synchronized boolean isClosed() {
<span class="pc bpc" id="L500" title="1 of 4 branches missed.">		return this.cache == null || this.thread == null;</span>
	}
	
	/**
	 * Closes the cache.
	 * This method is automatically invoked on caches for dead threads and whose time to live is over.
	 * A closed cache cannot be used anymore.
	 * @see #isClosed()
	 */
	protected synchronized void close() {
<span class="fc bfc" id="L510" title="All 2 branches covered.">		if (this.isClosed())</span>
<span class="fc" id="L511">			return;</span>
		
<span class="fc" id="L513">		this.reset();</span>
<span class="pc bpc" id="L514" title="1 of 2 branches missed.">		this.cache = null;</span>
<span class="fc" id="L515">		this.thread = null;</span>
<span class="fc" id="L516">		this.stopped = System.currentTimeMillis();</span>
<span class="fc" id="L517">		logger.fine(&quot;Cache stopped for thread &quot; + this.thread + &quot; with id &quot; + this.threadId);</span>
<span class="fc" id="L518">	}</span>

	@Override
	protected void finalize() throws Throwable {
<span class="fc" id="L522">		this.close();</span>
<span class="fc" id="L523">		super.finalize();</span>
<span class="fc" id="L524">	}</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.6.0.201210061924</span></div></body></html>